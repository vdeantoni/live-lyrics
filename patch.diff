diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 0000000..906b9d1
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,65 @@
+name: CI
+
+on: [pull_request]
+
+jobs:
+  test:
+    runs-on: ubuntu-latest
+    name: Tests
+
+    steps:
+      - name: Checkout repository
+        uses: actions/checkout@v4
+
+      - name: Set up Node.js
+        uses: actions/setup-node@v4
+        with:
+          node-version: "20"
+
+      - name: Set up pnpm
+        uses: pnpm/action-setup@v4
+
+      - name: Install dependencies
+        run: pnpm install
+
+      - name: Run format
+        run: pnpm format
+
+      - name: Run lint
+        run: pnpm lint
+
+      - name: Run tests
+        run: pnpm test
+
+  playwright:
+    timeout-minutes: 60
+    runs-on: ubuntu-latest
+    name: Playwright
+
+    steps:
+      - name: Checkout repository
+        uses: actions/checkout@v4
+
+      - name: Set up Node.js
+        uses: actions/setup-node@v4
+        with:
+          node-version: "20"
+
+      - name: Set up pnpm
+        uses: pnpm/action-setup@v4
+
+      - name: Install dependencies
+        run: pnpm install
+
+      - name: Install Playwright Browsers
+        run: pnpm --filter client test:e2e:install
+
+      - name: Run Playwright tests
+        run: pnpm --filter client test:e2e
+
+      - uses: actions/upload-artifact@v4
+        if: ${{ !cancelled() }}
+        with:
+          name: playwright-report
+          path: playwright-report/
+          retention-days: 30
diff --git a/.github/workflows/vrt.yml b/.github/workflows/vrt.yml
index fe6bf37..df8460b 100644
--- a/.github/workflows/vrt.yml
+++ b/.github/workflows/vrt.yml
@@ -1,6 +1,6 @@
 name: Visual Regression Tests
 
-on: [push, pull_request]
+on: [pull_request]
 
 jobs:
   lost-pixel:
diff --git a/.gitignore b/.gitignore
index d0ca6a9..13841a0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,15 @@
 node_modules
 .turbo
 *.log
+
+# Output
+dist/
+
+# Test related
+test-results/
+coverage/
+
+# Playwright reports
+playwright-report/
+test-results/
+.DS_Store
diff --git a/.husky/pre-commit b/.husky/pre-commit
new file mode 100644
index 0000000..656aae8
--- /dev/null
+++ b/.husky/pre-commit
@@ -0,0 +1,7 @@
+#!/bin/sh
+. "$(dirname "$0")/_/husky.sh"
+
+# Run format check, lint check, and test with Turborepo caching
+pnpm format:check
+pnpm lint:check
+pnpm test
\ No newline at end of file
diff --git a/.prettierignore b/.prettierignore
new file mode 100644
index 0000000..febd90a
--- /dev/null
+++ b/.prettierignore
@@ -0,0 +1,6 @@
+node_modules
+.turbo
+dist
+.claude
+.git
+.github
diff --git a/.prettierrc b/.prettierrc
index 0967ef4..b4bfed3 100644
--- a/.prettierrc
+++ b/.prettierrc
@@ -1 +1,3 @@
-{}
+{
+  "plugins": ["prettier-plugin-tailwindcss"]
+}
diff --git a/GEMINI.md b/GEMINI.md
index 8fede8e..05b0b99 100644
--- a/GEMINI.md
+++ b/GEMINI.md
@@ -11,41 +11,59 @@ This project is a web-based application that displays the lyrics of the song cur
 This is a [Turborepo](https://turbo.build/) monorepo project. Use these commands:
 
 - `pnpm dev`: Starts the development server for both the client and the server
-- `pnpm build`: Builds the client and the server
-- `pnpm lint`: Lints the client and the server
+- `pnpm build`: Builds the client and the server (optimized with Turbo cache)
+- `pnpm lint`: Applies linting fixes automatically
+- `pnpm lint:check`: Checks linting without applying fixes (used in pre-commit)
+- `pnpm format`: Applies code formatting with Prettier
+- `pnpm format:check`: Checks formatting without applying fixes (used in pre-commit)
+- `pnpm test`: Runs tests across all workspaces
 
 ### Individual workspace commands:
+
 - Client: `cd client && pnpm dev` (Vite dev server on port 5173)
 - Server: `cd server && pnpm dev` (Node.js server on port 4000)
 
 ### Testing commands:
-- `cd client && pnpm test:visual`: Run Playwright visual regression tests (local testing)
-- `cd client && pnpm test:visual:update`: Update Playwright visual test snapshots
-- Visual regression testing in CI/CD is handled by Lost Pixel (not suitable for local use)
+
+- `cd client && pnpm test`: Run Vitest tests once
+- `cd client && pnpm test:watch`: Run Vitest tests in watch mode
+- `cd client && pnpm test:ui`: Open Vitest UI
+- `cd client && pnpm test:coverage`: Generate coverage reports
+- Visual regression testing is handled by Lost Pixel in CI/CD only
+- E2E testing via Playwright (`client/tests/`) configured for simulated player environment
 
 ## Architecture
 
 ### Monorepo Structure
-- **Root**: Turborepo configuration with shared scripts
+
+- **Root**: Turborepo configuration with optimized caching based on Git-tracked files
 - **client/**: React + Vite frontend application
 - **server/**: Node.js + Hono backend server
 
+### Build System
+
+Both client and server compile to `dist/` directories:
+- **Client**: Vite builds to `client/dist/` (static assets)
+- **Server**: TypeScript compiles to `server/dist/` (Node.js modules)
+- **Caching**: Turbo cache based on actual Git-tracked file patterns for optimal performance
+
 ### Server (server/)
+
 - **Framework**: Hono (lightweight web framework)
 - **Runtime**: Node.js with TypeScript
 - **Apple Music Integration**: Uses AppleScript via `osascript` to query macOS Music app
 - **API Endpoints**:
   - `GET /music`: Returns current song info (name, artist, album, currentTime, duration, playerState)
   - `POST /music`: Controls playback (play/pause, seek)
-- **Build**: Uses `tsc` for TypeScript compilation
-- **Dev**: Uses `ts-node-dev` for hot reloading
+- **Build**: TypeScript compiles `src/` → `dist/` with `rootDir` and `outDir` configuration
 
 ### Client (client/)
+
 - **Framework**: React 19 with TypeScript
 - **Build Tool**: Vite
 - **Styling**: Tailwind CSS v4 with custom CSS animations
 - **Animations**: Framer Motion for complex animations (song name scrolling)
-- **State Management**: @tanstack/react-query with persistent localStorage cache
+- **State Management**: @tanstack/react-query with persistent localStorage cache + Jotai atoms
 - **Icons**: Lucide React for consistent iconography
 - **UI Components**: Radix UI primitives (slider, aspect-ratio, button)
 - **Key Features**:
@@ -56,6 +74,7 @@ This is a [Turborepo](https://turbo.build/) monorepo project. Use these commands
   - Animated song name scrolling with hover pause/resume
 
 ### Component Architecture
+
 - **LyricsVisualizer/**: Main lyrics display component hierarchy
   - `LyricsVisualizer.tsx`: Root container with layout orchestration
   - `LyricsProvider.tsx`: Data fetching, state management, and lyrics processing
@@ -66,42 +85,85 @@ This is a [Turborepo](https://turbo.build/) monorepo project. Use these commands
 - **ui/**: Reusable UI components (buttons, sliders, skeletons)
 
 ### Data Flow
+
 1. Server polls macOS Music app via AppleScript every request
 2. Client queries server every 300ms using React Query
 3. Client fetches additional data (artwork, lyrics) from external APIs
 4. React Query provides caching and persistence across sessions
 5. Components render synchronized lyrics with current playback position
 
-## Development Notes
+## Development & Troubleshooting
+
+### Pre-commit Hooks
+
+Husky runs these checks before each commit (will **fail** the commit if issues exist):
+- `format:check`: Ensures code is properly formatted
+- `lint:check`: Ensures no linting errors
+- `test`: Ensures all tests pass
+
+Use `pnpm format` and `pnpm lint` during development to auto-fix issues.
+
+### Turborepo Cache Optimization
+
+The `turbo.json` configuration uses Git-tracked file patterns as inputs for optimal cache performance:
+
+**Cache Performance**:
+- ✅ Good: Builds cached when no relevant files changed (35ms builds)
+- ❌ Bad: Builds always run when files outside inputs change constantly
+
+**⚠️ Critical**: When adding new config files (e.g., `tailwind.config.js`, `postcss.config.js`), update the relevant `inputs` arrays in `turbo.json`. Otherwise, Turbo uses stale cache when these configs change.
+
+**Example**: Adding `tailwind.config.js`:
+```json
+"build": {
+  "inputs": [
+    "src/**",
+    "package.json",
+    "tsconfig*.json",
+    "vite.config.*",
+    "tailwind.config.*"  // Add this
+  ]
+}
+```
+
+**Common Cache Issues**:
+- Generated files in `src/` (should be in `dist/` instead)
+- Using `**/*` patterns (too broad, includes temp files)
+- Missing config dependencies in inputs
 
-- **macOS Only**: Server requires macOS and the Music app for AppleScript integration
-- **TypeScript**: Both client and server use TypeScript
-- **Linting**: ESLint configured for both workspaces
-- **Formatting**: Prettier for code formatting
-- **Hot Reloading**: Available in both client (Vite) and server (ts-node-dev)
-- **Testing**: Lost Pixel for visual regression testing in CI/CD, Playwright for local testing
-- **State Management**: Uses Jotai atoms for local state management and React Query for server state
+### Testing Notes
 
-## Visual Regression Testing Workflow
+**Unit Tests (Vitest)**:
+- Located in `client/src/test/`
+- Run with `pnpm test`
+- Configured to exclude Playwright tests via `vitest.config.ts`
 
-This project uses **Lost Pixel** for visual regression testing in CI/CD to prevent unintended UI changes. Playwright is available for local testing and development.
+**E2E Tests (Playwright)**:
+- Located in `client/tests/`
+- Configured for simulated player environment
+- Tests use `[data-testid="..."]` selectors for reliability
+- Some tests skipped when incompatible with simulated environment
 
-### CI/CD Testing (Lost Pixel)
+**Visual Regression (Lost Pixel)**:
+- CI/CD only (not for local development)
+- Tests both portrait (768x1024) and landscape (1024x768) viewports
+- Configuration in `lostpixel.config.ts`
 
-- **Configuration**: `lostpixel.config.ts` in the root defines test pages and viewports
-- **Baselines**: Managed automatically by Lost Pixel cloud service
-- **Workflow**: `.github/workflows/vrt.yml` runs Lost Pixel tests on every push/PR
-- **Results**: Visual diffs and reports are available in the Lost Pixel dashboard
+### TypeScript Configuration
 
-### Local Development (Playwright)
+Both workspaces use consistent TypeScript setup:
+- **Server**: Compiles `src/` → `dist/` with `rootDir` and `outDir`
+- **Client**: Uses Vite's TypeScript handling
+- **Shared**: `tsconfig*.json` patterns tracked in Turbo inputs
 
-- **Purpose**: Quick feedback during development with `pnpm test:visual`
-- **Snapshots**: Saved in `client/tests/visual.spec.ts-snapshots`
-- **Note**: Local snapshots may differ from CI due to OS differences - use for development feedback only
+### macOS Development
 
-### Test Configuration
+- **Required**: macOS with Music app for AppleScript integration
+- **Server Development**: Uses `ts-node-dev` for hot reloading TypeScript
+- **Client Development**: Uses Vite's HMR for instant updates
 
-- **Portrait Mode**: 768x1024 viewport testing mobile layout
-- **Landscape Mode**: 1024x768 viewport testing desktop layout
-- **Base URL**: Tests run against preview server (port 4173)
-- **Test Pages**: Currently tests the home page in both orientations
\ No newline at end of file
+# important-instruction-reminders
+Do what has been asked; nothing more, nothing less.
+NEVER create files unless they're absolutely necessary for achieving your goal.
+ALWAYS prefer editing an existing file to creating a new one.
+NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.
\ No newline at end of file
diff --git a/client/.gitignore b/client/.gitignore
index 3f37851..335bd46 100644
--- a/client/.gitignore
+++ b/client/.gitignore
@@ -1,7 +1,8 @@
-# Build output
-dist/
 
-# Playwright reports
-playwright-report/
-test-results/
-.DS_Store
\ No newline at end of file
+# Playwright
+node_modules/
+/test-results/
+/playwright-report/
+/blob-report/
+/playwright/.cache/
+/playwright/.auth/
diff --git a/client/.npmrc b/client/.npmrc
deleted file mode 100644
index 5660f81..0000000
--- a/client/.npmrc
+++ /dev/null
@@ -1 +0,0 @@
-registry=https://registry.npmjs.org/
\ No newline at end of file
diff --git a/client/.prettierignore b/client/.prettierignore
new file mode 100644
index 0000000..6420206
--- /dev/null
+++ b/client/.prettierignore
@@ -0,0 +1,4 @@
+dist/
+node_modules/
+coverage/
+.cache/
\ No newline at end of file
diff --git a/client/package.json b/client/package.json
index a3dd325..fb4e17c 100644
--- a/client/package.json
+++ b/client/package.json
@@ -6,9 +6,21 @@
   "scripts": {
     "dev": "vite --host",
     "build": "tsc -b && vite build",
-    "lint": "eslint .",
+    "lint": "eslint . --fix",
+    "lint:check": "eslint .",
+    "format": "prettier --write .",
+    "format:check": "prettier --check .",
     "preview": "vite preview --host",
-    "test:lost-pixel": "lost-pixel"
+    "test": "vitest run",
+    "test:watch": "vitest",
+    "test:ui": "vitest --ui",
+    "test:coverage": "vitest --coverage",
+    "test:e2e": "playwright test",
+    "test:e2e:ui": "playwright test --ui",
+    "test:e2e:chromium": "playwright test --project=chromium",
+    "test:e2e:debug": "playwright test --debug",
+    "test:e2e:codegen": "playwright codegen",
+    "test:e2e:install": "playwright install --with-deps"
   },
   "dependencies": {
     "@radix-ui/react-aspect-ratio": "^1.1.7",
@@ -37,18 +49,25 @@
   },
   "devDependencies": {
     "@eslint/js": "^9.30.1",
+    "@playwright/test": "^1.55.1",
+    "@testing-library/jest-dom": "^6.8.0",
+    "@testing-library/react": "^16.3.0",
+    "@testing-library/user-event": "^14.6.1",
     "@types/node": "^24.0.13",
     "@types/react": "^19.1.8",
     "@types/react-dom": "^19.1.6",
     "@vitejs/plugin-react": "^4.6.0",
+    "@vitest/coverage-v8": "^3.2.4",
+    "@vitest/ui": "^3.2.4",
     "eslint": "^9.30.1",
     "eslint-plugin-react-hooks": "^5.2.0",
     "eslint-plugin-react-refresh": "^0.4.20",
     "globals": "^16.3.0",
-    "prettier": "^3.6.2",
+    "jsdom": "^27.0.0",
     "tw-animate-css": "^1.3.5",
     "typescript": "~5.8.3",
     "typescript-eslint": "^8.35.1",
-    "vite": "^7.0.4"
+    "vite": "^7.0.4",
+    "vitest": "^3.2.4"
   }
 }
diff --git a/client/playwright.config.ts b/client/playwright.config.ts
new file mode 100644
index 0000000..f8e3dc5
--- /dev/null
+++ b/client/playwright.config.ts
@@ -0,0 +1,69 @@
+import { defineConfig, devices } from "@playwright/test";
+
+/**
+ * See https://playwright.dev/docs/test-configuration.
+ */
+export default defineConfig({
+  testDir: "./tests",
+  /* Run tests in files in parallel */
+  fullyParallel: true,
+  /* Fail the build on CI if you accidentally left test.only in the source code. */
+  forbidOnly: !!process.env.CI,
+  /* Retry on CI only */
+  retries: process.env.CI ? 2 : 0,
+  /* Opt out of parallel tests on CI. */
+  workers: process.env.CI ? 1 : undefined,
+  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
+  reporter: "html",
+  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
+  use: {
+    /* Base URL to use in actions like `await page.goto('/')`. */
+    baseURL: process.env.CI
+      ? "http://172.17.0.1:4173"
+      : "http://127.0.0.1:4173",
+
+    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
+    trace: "on-first-retry",
+  },
+
+  /* Configure projects for major browsers */
+  projects: [
+    {
+      name: "chromium",
+      use: { ...devices["Desktop Chrome"] },
+    },
+
+    {
+      name: "firefox",
+      use: { ...devices["Desktop Firefox"] },
+    },
+
+    {
+      name: "webkit",
+      use: { ...devices["Desktop Safari"] },
+    },
+
+    /* Test against mobile viewports. */
+    {
+      name: "Mobile Chrome",
+      use: { ...devices["Pixel 5"] },
+    },
+    {
+      name: "Mobile Safari",
+      use: { ...devices["iPhone 12"] },
+    },
+
+    /* Test against tablet viewports. */
+    {
+      name: "iPad",
+      use: { ...devices["iPad Pro"] },
+    },
+  ],
+
+  /* Run your local dev server before starting the tests */
+  webServer: {
+    command: "pnpm preview",
+    url: "http://127.0.0.1:4173",
+    reuseExistingServer: !process.env.CI,
+  },
+});
diff --git a/client/src/App.tsx b/client/src/App.tsx
index 25ea880..c15d2c8 100644
--- a/client/src/App.tsx
+++ b/client/src/App.tsx
@@ -26,7 +26,7 @@ function App() {
           buster: "v1", // Cache version - increment to invalidate old caches
         }}
       >
-        <div className="flex flex-col h-full w-full items-center m-auto p-2 lg:p-4 xl-p-8">
+        <div className="xl-p-8 m-auto flex h-full w-full flex-col items-center p-2 lg:p-4">
           <LyricsVisualizer />
         </div>
         <ReactQueryDevtools initialIsOpen={false} />
diff --git a/client/src/atoms/sourceAtoms.ts b/client/src/atoms/sourceAtoms.ts
index cd034c9..6a040fe 100644
--- a/client/src/atoms/sourceAtoms.ts
+++ b/client/src/atoms/sourceAtoms.ts
@@ -1,41 +1,41 @@
-import { atom } from 'jotai'
-import type { MusicSource, SourceConfig } from '@/types/musicSource'
-import { HttpMusicSource } from '@/sources/httpMusicSource'
-import { SimulatedMusicSource } from '@/sources/simulatedMusicSource'
+import { atom } from "jotai";
+import type { MusicSource, SourceConfig } from "@/types/musicSource";
+import { HttpMusicSource } from "@/sources/httpMusicSource";
+import { SimulatedMusicSource } from "@/sources/simulatedMusicSource";
 
 /**
  * Available source configurations
  */
 export const availableSources: SourceConfig[] = [
   {
-    type: 'http',
-    name: 'Server',
-    options: { baseUrl: 'http://127.0.0.1:4000' },
+    type: "http",
+    name: "Server",
+    options: { baseUrl: "http://127.0.0.1:4000" },
   },
   {
-    type: 'simulated',
-    name: 'Player',
+    type: "simulated",
+    name: "Player",
     options: {},
   },
-]
+];
 
 /**
  * Current source configuration atom
  */
-export const currentSourceConfigAtom = atom<SourceConfig>(availableSources[1])
+export const currentSourceConfigAtom = atom<SourceConfig>(availableSources[1]);
 
 /**
  * Factory function to create music source instances
  */
 export function createMusicSource(config: SourceConfig): MusicSource {
   switch (config.type) {
-    case 'http':
-      return new HttpMusicSource(config.options?.baseUrl)
-    case 'simulated':
+    case "http":
+      return new HttpMusicSource(config.options?.baseUrl as string);
+    case "simulated":
       // Use singleton instance to persist state
-      return SimulatedMusicSource.getInstance()
+      return SimulatedMusicSource.getInstance();
     default:
-      throw new Error(`Unknown source type: ${config.type}`)
+      throw new Error(`Unknown source type: ${config.type}`);
   }
 }
 
@@ -43,9 +43,9 @@ export function createMusicSource(config: SourceConfig): MusicSource {
  * Current music source instance atom (derived from config)
  */
 export const currentMusicSourceAtom = atom<MusicSource>((get) => {
-  const config = get(currentSourceConfigAtom)
-  return createMusicSource(config)
-})
+  const config = get(currentSourceConfigAtom);
+  return createMusicSource(config);
+});
 
 /**
  * Atom to switch between sources
@@ -53,36 +53,36 @@ export const currentMusicSourceAtom = atom<MusicSource>((get) => {
 export const switchSourceAtom = atom(
   null,
   (_get, set, newConfig: SourceConfig) => {
-    set(currentSourceConfigAtom, newConfig)
-  }
-)
+    set(currentSourceConfigAtom, newConfig);
+  },
+);
 
 /**
  * Utility function to get available sources with their availability status
  */
-export const checkSourceAvailabilityAtom = atom(async (_get) => {
+export const checkSourceAvailabilityAtom = atom(async () => {
   const results = await Promise.allSettled(
     availableSources.map(async (config) => {
-      const source = createMusicSource(config)
-      const isAvailable = await source.isAvailable()
+      const source = createMusicSource(config);
+      const isAvailable = await source.isAvailable();
       return {
         config,
         source,
         isAvailable,
-      }
-    })
-  )
+      };
+    }),
+  );
 
   return results.map((result, index) => {
-    if (result.status === 'fulfilled') {
-      return result.value
+    if (result.status === "fulfilled") {
+      return result.value;
     } else {
       return {
         config: availableSources[index],
         source: null,
         isAvailable: false,
         error: result.reason,
-      }
+      };
     }
-  })
-})
\ No newline at end of file
+  });
+});
diff --git a/client/src/components/LyricsVisualizer/AnimatedSongName.tsx b/client/src/components/LyricsVisualizer/AnimatedSongName.tsx
index e60a566..8cfbd1a 100644
--- a/client/src/components/LyricsVisualizer/AnimatedSongName.tsx
+++ b/client/src/components/LyricsVisualizer/AnimatedSongName.tsx
@@ -152,12 +152,14 @@ const AnimatedSongName = ({
       controls.stop();
       controls.set({ x: 0 });
     }
+    // eslint-disable-next-line react-hooks/exhaustive-deps
   }, [isOverflowing, controls]);
 
   if (!songName) return null;
 
   return (
     <div
+      data-testid={"song-name"}
       ref={containerRef}
       className={`overflow-hidden ${className}`}
       onMouseEnter={handleMouseEnter}
@@ -165,7 +167,7 @@ const AnimatedSongName = ({
     >
       <motion.h2
         ref={textRef}
-        className="text-2xl font-semibold whitespace-nowrap text-center"
+        className="whitespace-nowrap text-center text-2xl font-semibold"
         animate={controls}
         onUpdate={(latest) => {
           if (typeof latest.x === "number") {
diff --git a/client/src/components/LyricsVisualizer/LyricsContent.tsx b/client/src/components/LyricsVisualizer/LyricsContent.tsx
index a394124..ae98a86 100644
--- a/client/src/components/LyricsVisualizer/LyricsContent.tsx
+++ b/client/src/components/LyricsVisualizer/LyricsContent.tsx
@@ -31,12 +31,14 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
 
       return (
         <div
-          key={`${lyricsData.tags?.ti || 'song'}-${index}-${line.text.slice(0, 10)}`} // More unique key
+          key={`${lyricsData.tags?.ti || "song"}-${index}-${line.text.slice(0, 10)}`} // More unique key
+          data-testid="lyrics-line"
+          data-current={isActive ? "true" : "false"}
           data-line-index={index} // Add data attribute for easier detection
           data-line-text={line.text.substring(0, 20)} // Add data attribute for text matching
-          className={`text-center font-normal my-3 opacity-50 transition-all duration-300 py-2.5 cursor-pointer transform ${
+          className={`my-3 transform cursor-pointer py-2.5 text-center font-normal opacity-50 transition-all duration-300 ${
             isActive
-              ? "font-bold opacity-100 scale-110 [text-shadow:0_0_10px_#fff,4px_4px_8px_rgba(0,0,0,0.5)]"
+              ? "scale-110 font-bold opacity-100 [text-shadow:0_0_10px_#fff,4px_4px_8px_rgba(0,0,0,0.5)]"
               : ""
           }`}
           style={{
@@ -69,8 +71,8 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
       }
     };
 
-    container.addEventListener('scroll', handleScroll);
-    return () => container.removeEventListener('scroll', handleScroll);
+    container.addEventListener("scroll", handleScroll);
+    return () => container.removeEventListener("scroll", handleScroll);
   }, [lyricsData]);
 
   // Restore scroll position when lyrics data loads (immediate)
@@ -89,7 +91,11 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
         // Use a second requestAnimationFrame to ensure scroll is complete
         requestAnimationFrame(() => {
           // Only check for active line if there actually is one (not at time 0)
-          if (!activeLine || (activeLine.index === undefined && activeLine.time === undefined)) return;
+          if (
+            !activeLine ||
+            (activeLine.index === undefined && activeLine.time === undefined)
+          )
+            return;
 
           // Wait longer for React to fully update the DOM with active classes
           setTimeout(() => {
@@ -99,7 +105,7 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
             // First try to find by class name
             for (let i = 0; i < container.children.length; i++) {
               const child = container.children[i] as HTMLElement;
-              if (child.className.includes('font-bold opacity-100 scale-110')) {
+              if (child.className.includes("font-bold opacity-100 scale-110")) {
                 activeLineElement = child;
                 break;
               }
@@ -107,7 +113,9 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
 
             // Fallback: try to find by index if activeLine has an index
             if (!activeLineElement && activeLine.index !== undefined) {
-              const potentialElement = container.children[activeLine.index] as HTMLElement;
+              const potentialElement = container.children[
+                activeLine.index
+              ] as HTMLElement;
               if (potentialElement) {
                 activeLineElement = potentialElement;
               }
@@ -117,7 +125,9 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
             if (!activeLineElement) {
               for (let i = 0; i < container.children.length; i++) {
                 const child = container.children[i] as HTMLElement;
-                if (child.textContent?.includes(activeLine.text.substring(0, 20))) {
+                if (
+                  child.textContent?.includes(activeLine.text.substring(0, 20))
+                ) {
                   activeLineElement = child;
                   break;
                 }
@@ -138,11 +148,17 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
             const lineBottomInViewport = lineTopInViewport + activeLineHeight;
 
             // If active line is not visible, scroll to it
-            if (lineTopInViewport < 0 || lineBottomInViewport > containerHeight) {
+            if (
+              lineTopInViewport < 0 ||
+              lineBottomInViewport > containerHeight
+            ) {
               const idealScrollTop =
                 activeLineTop - containerHeight / 2 + activeLineHeight / 2 + 64;
               const maxScrollTop = container.scrollHeight - containerHeight;
-              const targetScrollTop = Math.max(0, Math.min(idealScrollTop, maxScrollTop));
+              const targetScrollTop = Math.max(
+                0,
+                Math.min(idealScrollTop, maxScrollTop),
+              );
 
               container.scrollTo({
                 top: targetScrollTop,
@@ -174,7 +190,7 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
       // First try to find by class name
       for (let i = 0; i < container.children.length; i++) {
         const child = container.children[i] as HTMLElement;
-        if (child.className.includes('font-bold opacity-100 scale-110')) {
+        if (child.className.includes("font-bold opacity-100 scale-110")) {
           activeLineElement = child;
           break;
         }
@@ -182,7 +198,9 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
 
       // Fallback: try to find by index if activeLine has an index
       if (!activeLineElement && activeLine.index !== undefined) {
-        const potentialElement = container.children[activeLine.index] as HTMLElement;
+        const potentialElement = container.children[
+          activeLine.index
+        ] as HTMLElement;
         if (potentialElement) {
           activeLineElement = potentialElement;
         }
@@ -219,7 +237,10 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
       // 4. Clamp the scroll position to valid bounds
       // We can't scroll above 0 or past the maximum scrollable position.
       const maxScrollTop = container.scrollHeight - containerHeight;
-      const targetScrollTop = Math.max(0, Math.min(idealScrollTop, maxScrollTop));
+      const targetScrollTop = Math.max(
+        0,
+        Math.min(idealScrollTop, maxScrollTop),
+      );
 
       // 5. Scroll to the calculated position
       container.scrollTo({
@@ -253,7 +274,7 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
       // First try to find by class name
       for (let i = 0; i < container.children.length; i++) {
         const child = container.children[i] as HTMLElement;
-        if (child.className.includes('font-bold opacity-100 scale-110')) {
+        if (child.className.includes("font-bold opacity-100 scale-110")) {
           activeLineElement = child;
           break;
         }
@@ -261,7 +282,9 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
 
       // Fallback: try to find by index if activeLine has an index
       if (!activeLineElement && activeLine.index !== undefined) {
-        const potentialElement = container.children[activeLine.index] as HTMLElement;
+        const potentialElement = container.children[
+          activeLine.index
+        ] as HTMLElement;
         if (potentialElement) {
           activeLineElement = potentialElement;
         }
@@ -288,7 +311,10 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
       const idealScrollTop =
         activeLineTop - containerHeight / 2 + activeLineHeight / 2 + 64;
       const maxScrollTop = container.scrollHeight - containerHeight;
-      const targetScrollTop = Math.max(0, Math.min(idealScrollTop, maxScrollTop));
+      const targetScrollTop = Math.max(
+        0,
+        Math.min(idealScrollTop, maxScrollTop),
+      );
 
       container.scrollTo({
         top: targetScrollTop,
@@ -343,12 +369,13 @@ const LyricsContent: React.FC<LyricsContentProps> = ({
 
   return (
     <div
+      data-testid="lyrics-container"
       ref={contentRef}
-      className="w-full h-full px-6 lg:px-8 xl:px-10 overflow-auto scroll-smooth [&::-webkit-scrollbar]:hidden"
+      className="h-full w-full overflow-auto scroll-smooth px-6 lg:px-8 xl:px-10 [&::-webkit-scrollbar]:hidden"
     >
       <div
         ref={cursorRef}
-        className="absolute w-1 h-1 rounded-md bg-current opacity-20 transition-all duration-300"
+        className="absolute h-1 w-1 rounded-md bg-current opacity-20 transition-all duration-300"
       />
       {lines}
     </div>
diff --git a/client/src/components/LyricsVisualizer/LyricsDisplay.tsx b/client/src/components/LyricsVisualizer/LyricsDisplay.tsx
index 5bfc989..d0cfe23 100644
--- a/client/src/components/LyricsVisualizer/LyricsDisplay.tsx
+++ b/client/src/components/LyricsVisualizer/LyricsDisplay.tsx
@@ -1,6 +1,13 @@
 import { useEffect, useState, type PropsWithChildren } from "react";
 import { useAtomValue } from "jotai";
-import { songNameAtom, artistAtom, albumAtom, durationAtom, currentTimeAtom, isPlayingAtom } from "@/atoms/playerAtoms";
+import {
+  songNameAtom,
+  artistAtom,
+  albumAtom,
+  durationAtom,
+  currentTimeAtom,
+  isPlayingAtom,
+} from "@/atoms/playerAtoms";
 import { useArtworkFromSource } from "@/hooks/useSongSync";
 
 const LyricsDisplay = ({ children }: PropsWithChildren) => {
@@ -13,14 +20,17 @@ const LyricsDisplay = ({ children }: PropsWithChildren) => {
   const isPlaying = useAtomValue(isPlayingAtom);
 
   // Construct song object for artwork API
-  const song = songName && artist ? {
-    name: songName,
-    artist,
-    album: album || '',
-    duration,
-    currentTime,
-    isPlaying
-  } : undefined;
+  const song =
+    songName && artist
+      ? {
+          name: songName,
+          artist,
+          album: album || "",
+          duration,
+          currentTime,
+          isPlaying,
+        }
+      : undefined;
 
   const { data: artworks } = useArtworkFromSource(song);
 
@@ -41,9 +51,13 @@ const LyricsDisplay = ({ children }: PropsWithChildren) => {
   }, [artworks]);
 
   return (
-    <div className="relative h-full w-full overflow-hidden">
+    <div
+      data-testid="lyrics-display"
+      className="relative h-full w-full overflow-hidden"
+    >
       {/* Background Image Layer with Effects */}
       <div
+        data-testid="lyrics-background"
         className="absolute inset-0 bg-cover bg-center transition-all duration-1000 ease-in-out"
         style={{
           backgroundImage: `url(${currentArtworkUrl})`,
diff --git a/client/src/components/LyricsVisualizer/LyricsProvider.tsx b/client/src/components/LyricsVisualizer/LyricsProvider.tsx
index 03d9902..8a43f06 100644
--- a/client/src/components/LyricsVisualizer/LyricsProvider.tsx
+++ b/client/src/components/LyricsVisualizer/LyricsProvider.tsx
@@ -1,15 +1,17 @@
-import {
-  type LineData,
-  type WordData,
-  type LyricsData,
-} from "@/lib/api";
+import { type LineData, type WordData, type LyricsData } from "@/lib/api";
 import { useEffect, useState, useRef, useCallback } from "react";
 import LyricsContent from "./LyricsContent";
 import NoLyricsFound from "./NoLyricsFound";
 import Liricle from "liricle";
 import { useLyricsFromSource } from "@/hooks/useSongSync";
 import { useAtomValue } from "jotai";
-import { songNameAtom, artistAtom, albumAtom, durationAtom, currentTimeAtom } from "@/atoms/playerAtoms";
+import {
+  songNameAtom,
+  artistAtom,
+  albumAtom,
+  durationAtom,
+  currentTimeAtom,
+} from "@/atoms/playerAtoms";
 
 const LyricsProvider = () => {
   // Read song data from atoms (populated by useSongSync in parent)
@@ -20,16 +22,26 @@ const LyricsProvider = () => {
   const currentTime = useAtomValue(currentTimeAtom);
 
   // Construct song object for lyrics provider
-  const song = songName && artist ? {
-    name: songName,
-    artist,
-    album: album || '',
-    duration,
-    currentTime,
-    isPlaying: false // Not needed for lyrics fetching
-  } : undefined;
-
-  const { data: lrcContent, isLoading, isFetching, isSuccess } = useLyricsFromSource(song);
+  const song =
+    songName && artist
+      ? {
+          name: songName,
+          artist,
+          album: album || "",
+          duration,
+          currentTime,
+          isPlaying: false, // Not needed for lyrics fetching
+        }
+      : undefined;
+
+  const {
+    data: lrcContent,
+    isLoading,
+    isFetching,
+    isSuccess,
+    isError,
+    error,
+  } = useLyricsFromSource(song);
 
   const liricleRef = useRef<Liricle | null>(null);
   const [lyricsData, setLyricsData] = useState<LyricsData | null>(null);
@@ -43,7 +55,7 @@ const LyricsProvider = () => {
 
   // Delay showing "No Lyrics Found" to prevent flash during source switches
   useEffect(() => {
-    if (isSuccess && (!lrcContent || lrcContent.trim() === '')) {
+    if (isSuccess && (!lrcContent || lrcContent.trim() === "")) {
       const timer = setTimeout(() => setShowNoLyrics(true), 500); // 500ms delay
       return () => clearTimeout(timer);
     } else {
@@ -94,17 +106,40 @@ const LyricsProvider = () => {
     liricleRef.current.sync(currentTime);
   }, [currentTime]);
 
-  if (!song) return null;
+  if (!song) {
+    return (
+      <div
+        data-testid="no-music-message"
+        className="flex h-full min-h-96 items-center justify-center"
+      >
+        <div className="text-zinc-400">No music is currently playing</div>
+      </div>
+    );
+  }
 
   // Show loading state while fetching lyrics or if query hasn't completed successfully yet
   if (isLoading || isFetching || !isSuccess) {
     return (
-      <div className="flex items-center justify-center h-full min-h-96">
+      <div className="flex h-full min-h-96 items-center justify-center">
         <div className="text-zinc-400">Loading lyrics...</div>
       </div>
     );
   }
 
+  // Show error state if there was an error fetching lyrics
+  if (isError) {
+    return (
+      <div
+        data-testid="error-message"
+        className="flex h-full min-h-96 items-center justify-center"
+      >
+        <div className="text-red-400">
+          {error ? String(error) : "Failed to load lyrics"}
+        </div>
+      </div>
+    );
+  }
+
   // Only show NoLyricsFound after delay and when we definitively have no lyrics
   if (showNoLyrics) {
     return <NoLyricsFound songName={songName} artist={artist} />;
diff --git a/client/src/components/LyricsVisualizer/LyricsVisualizer.tsx b/client/src/components/LyricsVisualizer/LyricsVisualizer.tsx
index 7b4179b..f832b4f 100644
--- a/client/src/components/LyricsVisualizer/LyricsVisualizer.tsx
+++ b/client/src/components/LyricsVisualizer/LyricsVisualizer.tsx
@@ -9,10 +9,13 @@ const LyricsVisualizer = () => {
   useSongSync();
 
   return (
-    <div className="flex flex-col w-full h-full bg-zinc-800 rounded-2xl shadow-xl p-6 gap-4 mx-auto">
+    <div
+      data-testid="lyrics-visualizer"
+      className="mx-auto flex h-full w-full flex-col gap-4 rounded-2xl bg-zinc-800 p-6 shadow-xl"
+    >
       <LyricsDisplay>
         {/* Floating source switcher overlay */}
-        <div className="absolute top-4 right-4 z-20">
+        <div className="absolute right-4 top-4 z-20">
           <SourceSwitcher />
         </div>
         <LyricsProvider />
diff --git a/client/src/components/LyricsVisualizer/NoLyricsFound.tsx b/client/src/components/LyricsVisualizer/NoLyricsFound.tsx
index 8e3126f..e9c9cb8 100644
--- a/client/src/components/LyricsVisualizer/NoLyricsFound.tsx
+++ b/client/src/components/LyricsVisualizer/NoLyricsFound.tsx
@@ -7,31 +7,34 @@ interface NoLyricsFoundProps {
 
 const NoLyricsFound = ({ songName, artist }: NoLyricsFoundProps) => {
   return (
-    <div className="flex flex-col items-center justify-center h-full min-h-96 text-center px-6">
-      <div className="relative mb-6">
-        <div className="w-24 h-24 bg-zinc-700/50 rounded-full flex items-center justify-center mb-4">
-          <Music className="w-12 h-12 text-zinc-400" />
+    <div
+      data-testid="no-lyrics-message"
+      className="flex h-full min-h-96 flex-col items-center justify-center px-6 text-center"
+    >
+      <div data-testid="lyrics-error" className="relative mb-6">
+        <div className="mb-4 flex h-24 w-24 items-center justify-center rounded-full bg-zinc-700/50">
+          <Music className="h-12 w-12 text-zinc-400" />
         </div>
-        <div className="absolute -bottom-2 -right-2 w-8 h-8 bg-zinc-600 rounded-full flex items-center justify-center">
-          <Search className="w-4 h-4 text-zinc-300" />
+        <div className="absolute -bottom-2 -right-2 flex h-8 w-8 items-center justify-center rounded-full bg-zinc-600">
+          <Search className="h-4 w-4 text-zinc-300" />
         </div>
       </div>
 
-      <h3 className="text-xl font-semibold text-zinc-200 mb-2">
+      <h3 className="mb-2 text-xl font-semibold text-zinc-200">
         No Lyrics Found
       </h3>
 
       {songName && artist ? (
-        <p className="text-zinc-400 mb-4 max-w-md">
+        <p className="mb-4 max-w-md text-zinc-400">
           We couldn't find lyrics for "{songName}" by {artist}.
         </p>
       ) : (
-        <p className="text-zinc-400 mb-4 max-w-md">
+        <p className="mb-4 max-w-md text-zinc-400">
           We couldn't find lyrics for this song.
         </p>
       )}
 
-      <div className="text-sm text-zinc-500 space-y-1">
+      <div className="space-y-1 text-sm text-zinc-500">
         <p>• Try switching to Simulated Player for demo lyrics</p>
         <p>• Check if your local server has a /lyrics endpoint</p>
         <p>• Some songs may not be available in our lyrics database</p>
@@ -40,4 +43,4 @@ const NoLyricsFound = ({ songName, artist }: NoLyricsFoundProps) => {
   );
 };
 
-export default NoLyricsFound;
\ No newline at end of file
+export default NoLyricsFound;
diff --git a/client/src/components/LyricsVisualizer/Player.tsx b/client/src/components/LyricsVisualizer/Player.tsx
index c5f15b0..26551e8 100644
--- a/client/src/components/LyricsVisualizer/Player.tsx
+++ b/client/src/components/LyricsVisualizer/Player.tsx
@@ -51,26 +51,43 @@ const Player = () => {
   };
 
   return (
-    <div className="flex flex-col landscape:flex-row w-full gap-4">
-      <div className="flex flex-col min-h-14 max-h-20 landscape:max-w-[30%]">
+    <div
+      data-testid="player"
+      className="flex w-full flex-col gap-4 landscape:flex-row"
+    >
+      <div className="flex max-h-20 min-h-14 flex-col landscape:max-w-[30%]">
         <AnimatedSongName className="flex-1" songName={songName} />
-        <h3 className="text-muted-foreground self-center">{artist}</h3>
+        <h3
+          data-testid="artist-name"
+          className="text-muted-foreground self-center"
+        >
+          {artist}
+        </h3>
       </div>
       <div className="flex flex-1 items-center gap-3">
-        <span id="current-time" className="text-sm min-w-10 text-center">
+        <span
+          data-testid="current-time"
+          id="current-time"
+          className="min-w-10 text-center text-sm"
+        >
           {formatTime(currentTime)}
         </span>
         <Slider
+          data-testid="progress-slider"
           value={[currentTime]}
           min={0}
           max={duration || 0}
           step={0.1}
-          className="bg-zinc-700 rounded-md"
+          className="rounded-md bg-zinc-700"
           onValueChange={handleSliderChange}
           onPointerDown={handleSliderPointerDown}
           onPointerUp={handleSliderPointerUp}
         />
-        <span id="total-duration" className="text-sm min-w-10 text-center">
+        <span
+          data-testid="duration"
+          id="total-duration"
+          className="min-w-10 text-center text-sm"
+        >
           {formatTime(duration)}
         </span>
       </div>
@@ -79,23 +96,31 @@ const Player = () => {
         <Button
           size="sm"
           variant="ghost"
-          className="rounded-full p-2 h-10 w-10"
+          className="h-10 w-10 rounded-full p-2"
           aria-label="Search lyrics"
           onClick={() => console.log("Search clicked")}
         >
           <Search />
         </Button>
 
-        <div className="flex-1 flex items-center justify-center">
+        <div className="flex flex-1 items-center justify-center">
           {/* Play/Pause Button - Centered */}
           <Button
-            className="rounded-full h-12 w-12 flex items-center justify-center"
+            data-testid="play-pause-button"
+            className="flex h-12 w-12 items-center justify-center rounded-full"
             onClick={handlePlayPause}
+            aria-label={isPlaying ? "Pause" : "Play"}
           >
             {isPlaying ? (
-              <Pause style={{ width: "24px", height: "24px" }} />
+              <Pause
+                data-testid="pause-icon"
+                style={{ width: "24px", height: "24px" }}
+              />
             ) : (
-              <Play style={{ width: "24px", height: "24px" }} />
+              <Play
+                data-testid="play-icon"
+                style={{ width: "24px", height: "24px" }}
+              />
             )}
           </Button>
         </div>
@@ -104,7 +129,7 @@ const Player = () => {
         <Button
           size="sm"
           variant="ghost"
-          className="rounded-full p-2 h-10 w-10"
+          className="h-10 w-10 rounded-full p-2"
           aria-label="View playlists"
           onClick={() => console.log("Playlists clicked")}
         >
diff --git a/client/src/components/SourceSwitcher.tsx b/client/src/components/SourceSwitcher.tsx
index 543b9eb..5878207 100644
--- a/client/src/components/SourceSwitcher.tsx
+++ b/client/src/components/SourceSwitcher.tsx
@@ -28,7 +28,8 @@ const SourceSwitcher = () => {
 
   return (
     <motion.div
-      className="flex items-center bg-black/40 backdrop-blur-md rounded-full px-4 py-2 border border-white/10 shadow-lg cursor-pointer overflow-hidden"
+      data-testid="source-switcher"
+      className="flex cursor-pointer items-center overflow-hidden rounded-full border border-white/10 bg-black/40 px-4 py-2 shadow-lg backdrop-blur-md"
       onHoverStart={() => setIsHovered(true)}
       onHoverEnd={() => setIsHovered(false)}
       whileHover={{
@@ -41,6 +42,7 @@ const SourceSwitcher = () => {
       }}
     >
       <Switch
+        data-testid="source-option"
         id="server-mode"
         checked={isServerMode}
         onCheckedChange={handleToggle}
@@ -50,7 +52,7 @@ const SourceSwitcher = () => {
         {isHovered && (
           <motion.label
             htmlFor="server-mode"
-            className="text-sm font-medium text-white/90 cursor-pointer select-none whitespace-nowrap ml-3"
+            className="ml-3 cursor-pointer select-none whitespace-nowrap text-sm font-medium text-white/90"
             initial={{ opacity: 0, width: 0, marginLeft: 0 }}
             animate={{ opacity: 1, width: "auto", marginLeft: 12 }}
             exit={{ opacity: 0, width: 0, marginLeft: 0 }}
diff --git a/client/src/components/ui/button.tsx b/client/src/components/ui/button.tsx
index 9a779e8..a8a9a8e 100644
--- a/client/src/components/ui/button.tsx
+++ b/client/src/components/ui/button.tsx
@@ -59,4 +59,8 @@ function Button({
   );
 }
 
-export { Button, buttonVariants };
+export { Button };
+
+// Export buttonVariants in a separate file if needed elsewhere
+// eslint-disable-next-line react-refresh/only-export-components
+export { buttonVariants };
diff --git a/client/src/components/ui/slider.tsx b/client/src/components/ui/slider.tsx
index 0b2113b..ed5601a 100644
--- a/client/src/components/ui/slider.tsx
+++ b/client/src/components/ui/slider.tsx
@@ -29,7 +29,7 @@ function Slider({
       min={min}
       max={max}
       className={cn(
-        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col cursor-pointer",
+        "relative flex w-full cursor-pointer touch-none select-none items-center data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col data-[disabled]:opacity-50",
         className,
       )}
       {...props}
@@ -37,7 +37,7 @@ function Slider({
       <SliderPrimitive.Track
         data-slot="slider-track"
         className={cn(
-          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-2 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5",
+          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-2 data-[orientation=vertical]:h-full data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-1.5",
         )}
       >
         <SliderPrimitive.Range
@@ -51,7 +51,7 @@ function Slider({
         <SliderPrimitive.Thumb
           data-slot="slider-thumb"
           key={index}
-          className="border-primary bg-background ring-ring/50 block size-5 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
+          className="border-primary bg-background ring-ring/50 focus-visible:outline-hidden block size-5 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50"
         />
       ))}
     </SliderPrimitive.Root>
diff --git a/client/src/components/ui/switch.tsx b/client/src/components/ui/switch.tsx
index b0363e3..7d3f3d2 100644
--- a/client/src/components/ui/switch.tsx
+++ b/client/src/components/ui/switch.tsx
@@ -1,7 +1,7 @@
-import * as React from "react"
-import * as SwitchPrimitive from "@radix-ui/react-switch"
+import * as React from "react";
+import * as SwitchPrimitive from "@radix-ui/react-switch";
 
-import { cn } from "@/lib/utils"
+import { cn } from "@/lib/utils";
 
 function Switch({
   className,
@@ -11,19 +11,19 @@ function Switch({
     <SwitchPrimitive.Root
       data-slot="switch"
       className={cn(
-        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
-        className
+        "data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 shadow-xs peer inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent outline-none transition-all focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
+        className,
       )}
       {...props}
     >
       <SwitchPrimitive.Thumb
         data-slot="switch-thumb"
         className={cn(
-          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
+          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0",
         )}
       />
     </SwitchPrimitive.Root>
-  )
+  );
 }
 
-export { Switch }
+export { Switch };
diff --git a/client/src/docs/SOURCES.md b/client/src/docs/SOURCES.md
deleted file mode 100644
index 9dbede0..0000000
--- a/client/src/docs/SOURCES.md
+++ /dev/null
@@ -1,72 +0,0 @@
-# Music Source System
-
-The Live Lyrics app now supports multiple music sources through a flexible interface system.
-
-## Architecture
-
-### MusicSource Interface
-
-All music sources implement the `MusicSource` interface:
-
-```typescript
-interface MusicSource {
-  getSong(): Promise<Song>     // Get current song info
-  play(): Promise<void>        // Start/resume playback
-  pause(): Promise<void>       // Pause playback
-  seek(time: number): Promise<void>  // Seek to position
-  getId(): string              // Unique identifier
-  getName(): string            // Human-readable name
-  isAvailable(): Promise<boolean>    // Check availability
-}
-```
-
-## Available Sources
-
-### HTTP Source (`HttpMusicSource`)
-- Connects to the real server at `http://127.0.0.1:4000`
-- Controls actual Apple Music playback
-- Best for production use
-
-### Simulated Source (`SimulatedMusicSource`)
-- In-memory player with internal clock
-- Demo playlist with classic songs
-- Perfect for development and testing
-- Features:
-  - Auto-advance to next song
-  - Realistic timing simulation
-  - No external dependencies
-
-## Usage
-
-### Source Switching
-Use the source switcher UI at the top of the app to toggle between:
-- **Local Server** (HTTP) - Real Apple Music control
-- **Simulated Player** - Demo mode
-
-### Adding New Sources
-1. Implement the `MusicSource` interface
-2. Add to `availableSources` in `sourceAtoms.ts`
-3. Update `createMusicSource` factory function
-
-## Benefits
-
-- **Flexibility**: Easy to add new music services
-- **Testing**: Simulated source for reliable development
-- **Abstraction**: UI code doesn't need to know about specific sources
-- **Extensibility**: Foundation for Spotify, YouTube Music, etc.
-
-## Example: Custom Source
-
-```typescript
-class SpotifyMusicSource implements MusicSource {
-  async getSong(): Promise<Song> {
-    // Spotify Web API integration
-  }
-
-  async play(): Promise<void> {
-    // Spotify play command
-  }
-
-  // ... implement other methods
-}
-```
\ No newline at end of file
diff --git a/client/src/providers/httpLyricsProvider.ts b/client/src/providers/httpLyricsProvider.ts
index 46bbdac..d944170 100644
--- a/client/src/providers/httpLyricsProvider.ts
+++ b/client/src/providers/httpLyricsProvider.ts
@@ -1,110 +1,130 @@
-import type { Song } from '@/lib/api'
-import type { LyricsProvider } from '@/types/musicSource'
+import type { Song } from "@/lib/api";
+import type { LyricsProvider } from "@/types/musicSource";
 
 interface LRCLibTrack {
-  id: number
-  trackName: string
-  artistName: string
-  albumName: string
-  duration: number
-  instrumental: boolean
-  plainLyrics: string | null
-  syncedLyrics: string | null
+  id: number;
+  trackName: string;
+  artistName: string;
+  albumName: string;
+  duration: number;
+  instrumental: boolean;
+  plainLyrics: string | null;
+  syncedLyrics: string | null;
 }
 
 /**
  * HTTP-based lyrics provider that first tries local server, then falls back to LrcLib API
  */
 export class HttpLyricsProvider implements LyricsProvider {
-  private localServerUrl: string
-  private lrcLibUrl: string
-
-  constructor(localServerUrl: string = 'http://127.0.0.1:4000', lrcLibUrl: string = 'https://lrclib.net/api') {
-    this.localServerUrl = localServerUrl
-    this.lrcLibUrl = lrcLibUrl
+  private localServerUrl: string;
+  private lrcLibUrl: string;
+
+  constructor(
+    localServerUrl: string = "http://127.0.0.1:4000",
+    lrcLibUrl: string = "https://lrclib.net/api",
+  ) {
+    this.localServerUrl = localServerUrl;
+    this.lrcLibUrl = lrcLibUrl;
   }
 
   async getLyrics(song: Song): Promise<string | null> {
     if (!song.name || !song.artist) {
-      return null
+      return null;
     }
 
     // First try to get lyrics from local server
     try {
-      const localResponse = await fetch(`${this.localServerUrl}/lyrics`)
+      const localResponse = await fetch(`${this.localServerUrl}/lyrics`);
       if (localResponse.ok) {
-        const lyrics = await localResponse.text()
+        const lyrics = await localResponse.text();
         if (lyrics && lyrics.trim()) {
-          console.log('Got lyrics from local server');
-          return lyrics
+          console.log("Got lyrics from local server");
+          return lyrics;
         }
       }
     } catch (error) {
-      console.log('Local server lyrics not available, trying LrcLib:', error)
+      console.log("Local server lyrics not available, trying LrcLib:", error);
     }
 
     // Fallback to LrcLib API
     try {
-      const searchUrl = new URL(`${this.lrcLibUrl}/search`)
-      searchUrl.searchParams.set('track_name', song.name)
-      searchUrl.searchParams.set('artist_name', song.artist)
+      const searchUrl = new URL(`${this.lrcLibUrl}/search`);
+      searchUrl.searchParams.set("track_name", song.name);
+      searchUrl.searchParams.set("artist_name", song.artist);
       if (song.album) {
-        searchUrl.searchParams.set('album_name', song.album)
+        searchUrl.searchParams.set("album_name", song.album);
       }
 
-      const response = await fetch(searchUrl.toString())
+      const response = await fetch(searchUrl.toString());
 
       if (!response.ok) {
-        console.warn(`LrcLib search failed: ${response.status}`)
-        return null
+        console.warn(`LrcLib search failed: ${response.status}`);
+        return null;
       }
 
-      const tracks: LRCLibTrack[] = await response.json()
+      const tracks: LRCLibTrack[] = await response.json();
 
       if (!Array.isArray(tracks) || tracks.length === 0) {
-        console.log('No lyrics found in LrcLib for:', song.name, 'by', song.artist)
-        return null
+        console.log(
+          "No lyrics found in LrcLib for:",
+          song.name,
+          "by",
+          song.artist,
+        );
+        return null;
       }
 
       // Find the best match (first one for now, could implement better matching)
-      const track = tracks[0]
-      console.log('Found lyrics in LrcLib for:', track.trackName, 'by', track.artistName)
+      const track = tracks[0];
+      console.log(
+        "Found lyrics in LrcLib for:",
+        track.trackName,
+        "by",
+        track.artistName,
+      );
 
       // Prefer synced lyrics, fall back to plain lyrics
-      return track.syncedLyrics || track.plainLyrics || null
+      return track.syncedLyrics || track.plainLyrics || null;
     } catch (error) {
-      console.error('Failed to fetch lyrics from LrcLib:', error)
-      return null
+      console.error("Failed to fetch lyrics from LrcLib:", error);
+      return null;
     }
   }
 
   getId(): string {
-    return 'http-lrclib'
+    return "http-lrclib";
   }
 
   getName(): string {
-    return 'HTTP Server + LrcLib'
+    return "HTTP Server + LrcLib";
   }
 
   async supportsLyrics(song: Song): Promise<boolean> {
     // LrcLib supports most songs if they have name and artist
-    return !!(song.name && song.artist)
+    return !!(song.name && song.artist);
   }
 
   async isAvailable(): Promise<boolean> {
     // Check if either local server or LrcLib is available
     try {
-      const localCheck = await fetch(`${this.localServerUrl}/music`, { method: 'HEAD' })
-      if (localCheck.ok) return true
-    } catch {}
+      const localCheck = await fetch(`${this.localServerUrl}/music`, {
+        method: "HEAD",
+      });
+      if (localCheck.ok) return true;
+    } catch {
+      // Local server not available, ignore error
+    }
 
     try {
-      const response = await fetch(`${this.lrcLibUrl}/search?track_name=test&artist_name=test`, {
-        method: 'HEAD',
-      })
-      return response.ok || response.status === 404 // 404 is fine, means API is working
+      const response = await fetch(
+        `${this.lrcLibUrl}/search?track_name=test&artist_name=test`,
+        {
+          method: "HEAD",
+        },
+      );
+      return response.ok || response.status === 404; // 404 is fine, means API is working
     } catch {
-      return false
+      return false;
     }
   }
-}
\ No newline at end of file
+}
diff --git a/client/src/providers/itunesArtworkProvider.ts b/client/src/providers/itunesArtworkProvider.ts
index 39f3e3b..eafdca3 100644
--- a/client/src/providers/itunesArtworkProvider.ts
+++ b/client/src/providers/itunesArtworkProvider.ts
@@ -1,12 +1,12 @@
-import type { Song } from '@/lib/api'
-import type { ArtworkProvider } from '@/types/musicSource'
+import type { Song } from "@/lib/api";
+import type { ArtworkProvider } from "@/types/musicSource";
 
 interface iTunesSearchResult {
-  resultCount: number
+  resultCount: number;
   results: {
-    artworkUrl100: string
-    [key: string]: unknown
-  }[]
+    artworkUrl100: string;
+    [key: string]: unknown;
+  }[];
 }
 
 /**
@@ -15,7 +15,7 @@ interface iTunesSearchResult {
 export class ITunesArtworkProvider implements ArtworkProvider {
   async getArtwork(song: Song): Promise<string[]> {
     if (!song.name || !song.artist) {
-      return []
+      return [];
     }
 
     try {
@@ -23,38 +23,41 @@ export class ITunesArtworkProvider implements ArtworkProvider {
         `https://itunes.apple.com/search?term=${encodeURIComponent(
           song.artist,
         )}+${encodeURIComponent(song.name)}&entity=song&limit=1`,
-      )
-      const json: iTunesSearchResult = await response.json()
+      );
+      const json: iTunesSearchResult = await response.json();
 
       if (!json.results?.length) {
-        return []
+        return [];
       }
 
       return json.results.map((art) =>
-        art.artworkUrl100.replace("100x100bb", "1000x1000bb")
-      )
+        art.artworkUrl100.replace("100x100bb", "1000x1000bb"),
+      );
     } catch (error) {
-      console.error('Failed to fetch artwork from iTunes:', error)
-      return []
+      console.error("Failed to fetch artwork from iTunes:", error);
+      return [];
     }
   }
 
   getId(): string {
-    return 'itunes-artwork'
+    return "itunes-artwork";
   }
 
   getName(): string {
-    return 'iTunes API'
+    return "iTunes API";
   }
 
   async isAvailable(): Promise<boolean> {
     try {
-      const response = await fetch('https://itunes.apple.com/search?term=test&limit=1', {
-        method: 'HEAD',
-      })
-      return response.ok
+      const response = await fetch(
+        "https://itunes.apple.com/search?term=test&limit=1",
+        {
+          method: "HEAD",
+        },
+      );
+      return response.ok;
     } catch {
-      return false
+      return false;
     }
   }
-}
\ No newline at end of file
+}
diff --git a/client/src/providers/simulatedLyricsProvider.ts b/client/src/providers/simulatedLyricsProvider.ts
index abe08d0..84a5a54 100644
--- a/client/src/providers/simulatedLyricsProvider.ts
+++ b/client/src/providers/simulatedLyricsProvider.ts
@@ -1,12 +1,12 @@
-import type { Song } from '@/lib/api'
-import type { LyricsProvider } from '@/types/musicSource'
+import type { Song } from "@/lib/api";
+import type { LyricsProvider } from "@/types/musicSource";
 
 /**
  * Simulated lyrics provider with hardcoded demo lyrics
  */
 export class SimulatedLyricsProvider implements LyricsProvider {
   private lyricsDatabase: Record<string, string> = {
-    'bohemian-rhapsody-queen': `[00:00.00] Is this the real life?
+    "bohemian-rhapsody-queen": `[00:00.00] Is this the real life?
 [00:03.50] Is this just fantasy?
 [00:07.00] Caught in a landslide
 [00:09.50] No escape from reality
@@ -25,7 +25,7 @@ export class SimulatedLyricsProvider implements LyricsProvider {
 [00:55.50] Mama, life had just begun
 [00:59.00] But now I've gone and thrown it all away`,
 
-    'stairway-to-heaven-led-zeppelin': `[00:00.00] There's a lady who's sure
+    "stairway-to-heaven-led-zeppelin": `[00:00.00] There's a lady who's sure
 [00:04.00] All that glitters is gold
 [00:08.00] And she's buying a stairway to heaven
 [00:16.00] When she gets there she knows
@@ -39,7 +39,7 @@ export class SimulatedLyricsProvider implements LyricsProvider {
 [01:04.00] There's a songbird who sings
 [01:08.00] Sometimes all of our thoughts are misgiven`,
 
-    'hotel-california-eagles': `[00:00.00] Welcome to the Hotel California
+    "hotel-california-eagles": `[00:00.00] Welcome to the Hotel California
 [00:04.00] Such a lovely place
 [00:06.50] (Such a lovely place)
 [00:08.00] Such a lovely face
@@ -55,7 +55,7 @@ export class SimulatedLyricsProvider implements LyricsProvider {
 [00:48.00] Some dance to remember
 [00:52.00] Some dance to forget`,
 
-    'imagine-john-lennon': `[00:00.00] Imagine there's no heaven
+    "imagine-john-lennon": `[00:00.00] Imagine there's no heaven
 [00:06.00] It's easy if you try
 [00:12.00] No hell below us
 [00:18.00] Above us only sky
@@ -72,7 +72,7 @@ export class SimulatedLyricsProvider implements LyricsProvider {
 [01:24.00] I hope someday you'll join us
 [01:30.00] And the world will be as one`,
 
-    'sweet-child-o-mine-guns-n-roses': `[00:00.00] She's got a smile that it seems to me
+    "sweet-child-o-mine-guns-n-roses": `[00:00.00] She's got a smile that it seems to me
 [00:04.00] Reminds me of childhood memories
 [00:08.00] Where everything was as fresh as the bright blue sky
 [00:16.00] Now and then when I see her face
@@ -84,53 +84,53 @@ export class SimulatedLyricsProvider implements LyricsProvider {
 [00:48.00] She's got eyes of the bluest skies
 [00:52.00] As if they thought of rain
 [00:56.00] I hate to look into those eyes
-[01:00.00] And see an ounce of pain`
-  }
+[01:00.00] And see an ounce of pain`,
+  };
 
   private getSongKey(song: Song): string {
     // Create a normalized key for the song
-    const name = song.name?.toLowerCase().replace(/[^a-z0-9]/g, '-') || ''
-    const artist = song.artist?.toLowerCase().replace(/[^a-z0-9]/g, '-') || ''
-    return `${name}-${artist}`
+    const name = song.name?.toLowerCase().replace(/[^a-z0-9]/g, "-") || "";
+    const artist = song.artist?.toLowerCase().replace(/[^a-z0-9]/g, "-") || "";
+    return `${name}-${artist}`;
   }
 
   async getLyrics(song: Song): Promise<string | null> {
     // Simulate network delay
-    await new Promise(resolve => setTimeout(resolve, 100))
+    await new Promise((resolve) => setTimeout(resolve, 100));
 
-    const key = this.getSongKey(song)
-    return this.lyricsDatabase[key] || null
+    const key = this.getSongKey(song);
+    return this.lyricsDatabase[key] || null;
   }
 
   getId(): string {
-    return 'simulated-lyrics'
+    return "simulated-lyrics";
   }
 
   getName(): string {
-    return 'Simulated Lyrics'
+    return "Simulated Lyrics";
   }
 
   async supportsLyrics(song: Song): Promise<boolean> {
-    const key = this.getSongKey(song)
-    return key in this.lyricsDatabase
+    const key = this.getSongKey(song);
+    return key in this.lyricsDatabase;
   }
 
   async isAvailable(): Promise<boolean> {
-    return true // Always available
+    return true; // Always available
   }
 
   /**
    * Add lyrics to the simulated database
    */
   addLyrics(song: Song, lyrics: string): void {
-    const key = this.getSongKey(song)
-    this.lyricsDatabase[key] = lyrics
+    const key = this.getSongKey(song);
+    this.lyricsDatabase[key] = lyrics;
   }
 
   /**
    * Get all available songs with lyrics
    */
   getAvailableSongs(): string[] {
-    return Object.keys(this.lyricsDatabase)
+    return Object.keys(this.lyricsDatabase);
   }
-}
\ No newline at end of file
+}
diff --git a/client/src/sources/httpMusicSource.ts b/client/src/sources/httpMusicSource.ts
index f0f0083..43183d9 100644
--- a/client/src/sources/httpMusicSource.ts
+++ b/client/src/sources/httpMusicSource.ts
@@ -1,101 +1,105 @@
-import type { Song } from '@/lib/api'
-import type { MusicSource, LyricsProvider, ArtworkProvider } from '@/types/musicSource'
-import { HttpLyricsProvider } from '@/providers/httpLyricsProvider'
-import { ITunesArtworkProvider } from '@/providers/itunesArtworkProvider'
+import type { Song } from "@/lib/api";
+import type {
+  MusicSource,
+  LyricsProvider,
+  ArtworkProvider,
+} from "@/types/musicSource";
+import { HttpLyricsProvider } from "@/providers/httpLyricsProvider";
+import { ITunesArtworkProvider } from "@/providers/itunesArtworkProvider";
 
 /**
  * HTTP-based music source that communicates with a real server
  */
 export class HttpMusicSource implements MusicSource {
-  private baseUrl: string
-  private lyricsProvider: LyricsProvider
-  private artworkProvider: ArtworkProvider
-
-  constructor(baseUrl: string = 'http://127.0.0.1:4000') {
-    this.baseUrl = baseUrl
-    this.lyricsProvider = new HttpLyricsProvider()
-    this.artworkProvider = new ITunesArtworkProvider()
+  private baseUrl: string;
+  private lyricsProvider: LyricsProvider;
+  private artworkProvider: ArtworkProvider;
+
+  constructor(baseUrl: string = "http://127.0.0.1:4000") {
+    this.baseUrl = baseUrl;
+    this.lyricsProvider = new HttpLyricsProvider();
+    this.artworkProvider = new ITunesArtworkProvider();
   }
 
   async getSong(): Promise<Song> {
-    const response = await fetch(`${this.baseUrl}/music`)
+    const response = await fetch(`${this.baseUrl}/music`);
 
     if (!response.ok) {
-      throw new Error(`Failed to fetch song: ${response.status}`)
+      throw new Error(`Failed to fetch song: ${response.status}`);
     }
 
-    const json = await response.json()
+    const json = await response.json();
 
     return {
-      name: json.name || 'Unknown Track',
-      artist: json.artist || 'Unknown Artist',
-      album: json.album || 'Unknown Album',
+      name: json.name || "Unknown Track",
+      artist: json.artist || "Unknown Artist",
+      album: json.album || "Unknown Album",
       duration: json.duration || 0,
       currentTime: parseFloat(json.currentTime || 0),
-      isPlaying: json.playerState === 'playing',
-    }
+      isPlaying: json.playerState === "playing",
+    };
   }
 
   async play(): Promise<void> {
     const response = await fetch(`${this.baseUrl}/music`, {
-      method: 'POST',
-      headers: { 'Content-Type': 'application/json' },
-      body: JSON.stringify({ action: 'play' }),
-    })
+      method: "POST",
+      headers: { "Content-Type": "application/json" },
+      body: JSON.stringify({ action: "play" }),
+    });
 
     if (!response.ok) {
-      throw new Error(`Failed to play: ${response.status}`)
+      throw new Error(`Failed to play: ${response.status}`);
     }
   }
 
   async pause(): Promise<void> {
     const response = await fetch(`${this.baseUrl}/music`, {
-      method: 'POST',
-      headers: { 'Content-Type': 'application/json' },
-      body: JSON.stringify({ action: 'pause' }),
-    })
+      method: "POST",
+      headers: { "Content-Type": "application/json" },
+      body: JSON.stringify({ action: "pause" }),
+    });
 
     if (!response.ok) {
-      throw new Error(`Failed to pause: ${response.status}`)
+      throw new Error(`Failed to pause: ${response.status}`);
     }
   }
 
   async seek(time: number): Promise<void> {
     const response = await fetch(`${this.baseUrl}/music`, {
-      method: 'POST',
-      headers: { 'Content-Type': 'application/json' },
-      body: JSON.stringify({ action: 'seek', time }),
-    })
+      method: "POST",
+      headers: { "Content-Type": "application/json" },
+      body: JSON.stringify({ action: "seek", time }),
+    });
 
     if (!response.ok) {
-      throw new Error(`Failed to seek: ${response.status}`)
+      throw new Error(`Failed to seek: ${response.status}`);
     }
   }
 
   getId(): string {
-    return `http-${this.baseUrl.replace(/[^a-zA-Z0-9]/g, '-')}`
+    return `http-${this.baseUrl.replace(/[^a-zA-Z0-9]/g, "-")}`;
   }
 
   getName(): string {
-    return `HTTP Server (${this.baseUrl})`
+    return `HTTP Server (${this.baseUrl})`;
   }
 
   async isAvailable(): Promise<boolean> {
     try {
       const response = await fetch(`${this.baseUrl}/music`, {
-        method: 'GET',
-      })
-      return response.ok
+        method: "GET",
+      });
+      return response.ok;
     } catch {
-      return false
+      return false;
     }
   }
 
   getLyricsProvider(): LyricsProvider | null {
-    return this.lyricsProvider
+    return this.lyricsProvider;
   }
 
   getArtworkProvider(): ArtworkProvider | null {
-    return this.artworkProvider
+    return this.artworkProvider;
   }
-}
\ No newline at end of file
+}
diff --git a/client/src/sources/simulatedMusicSource.ts b/client/src/sources/simulatedMusicSource.ts
index 8af2ef8..3453c74 100644
--- a/client/src/sources/simulatedMusicSource.ts
+++ b/client/src/sources/simulatedMusicSource.ts
@@ -1,5 +1,9 @@
 import type { Song } from "@/lib/api";
-import type { MusicSource, LyricsProvider, ArtworkProvider } from "@/types/musicSource";
+import type {
+  MusicSource,
+  LyricsProvider,
+  ArtworkProvider,
+} from "@/types/musicSource";
 import { SimulatedLyricsProvider } from "@/providers/simulatedLyricsProvider";
 import { ITunesArtworkProvider } from "@/providers/itunesArtworkProvider";
 
diff --git a/client/src/test/LyricsProvider.integration.test.tsx b/client/src/test/LyricsProvider.integration.test.tsx
new file mode 100644
index 0000000..1039ce4
--- /dev/null
+++ b/client/src/test/LyricsProvider.integration.test.tsx
@@ -0,0 +1,225 @@
+import { describe, it, expect, vi, beforeEach } from "vitest";
+import { render, screen, waitFor } from "@testing-library/react";
+import { Provider } from "jotai";
+import type { UseQueryResult } from "@tanstack/react-query";
+
+// Mock Liricle first
+const mockLiricleInstance = {
+  parse: vi.fn(),
+  on: vi.fn(),
+  load: vi.fn(),
+  sync: vi.fn(),
+};
+
+vi.mock("liricle", () => ({
+  default: vi.fn().mockImplementation(() => mockLiricleInstance),
+}));
+
+// Mock the hooks and atoms
+vi.mock("@/hooks/useSongSync", () => ({
+  useLyricsFromSource: vi.fn(),
+}));
+
+vi.mock("@/atoms/playerAtoms", () => ({
+  songNameAtom: { toString: () => "songNameAtom" },
+  artistAtom: { toString: () => "artistAtom" },
+  albumAtom: { toString: () => "albumAtom" },
+  durationAtom: { toString: () => "durationAtom" },
+  currentTimeAtom: { toString: () => "currentTimeAtom" },
+}));
+
+vi.mock("jotai", async () => {
+  const actual = await vi.importActual("jotai");
+  return {
+    ...actual,
+    useAtomValue: vi.fn(),
+  };
+});
+
+// Mock child components
+vi.mock("../components/LyricsVisualizer/LyricsContent", () => ({
+  default: ({ lyricsData }: { lyricsData: unknown }) => (
+    <div data-testid="lyrics-content">
+      {lyricsData ? "Lyrics loaded" : "No lyrics"}
+    </div>
+  ),
+}));
+
+vi.mock("../components/LyricsVisualizer/NoLyricsFound", () => ({
+  default: () => <div data-testid="no-lyrics">No lyrics found</div>,
+}));
+
+import LyricsProvider from "../components/LyricsVisualizer/LyricsProvider";
+import { useLyricsFromSource } from "@/hooks/useSongSync";
+import { useAtomValue } from "jotai";
+
+// Helper to create proper UseQueryResult mocks
+const createMockQueryResult = (
+  overrides: Partial<UseQueryResult<string, Error>>,
+): UseQueryResult<string, Error> =>
+  ({
+    data: undefined,
+    isLoading: false,
+    isFetching: false,
+    isSuccess: false,
+    isError: false,
+    isPending: false,
+    status: "pending" as const,
+    fetchStatus: "idle" as const,
+    error: null,
+    dataUpdatedAt: 0,
+    errorUpdatedAt: 0,
+    failureCount: 0,
+    failureReason: null,
+    errorUpdateCount: 0,
+    isFetched: false,
+    isFetchedAfterMount: false,
+    isInitialLoading: false,
+    isPlaceholderData: false,
+    isRefetching: false,
+    isStale: false,
+    refetch: vi.fn(),
+    ...overrides,
+  }) as UseQueryResult<string, Error>;
+
+describe("LyricsProvider Integration", () => {
+  beforeEach(() => {
+    vi.clearAllMocks();
+
+    // Reset mock instance
+    mockLiricleInstance.on.mockClear();
+    mockLiricleInstance.load.mockClear();
+    mockLiricleInstance.sync.mockClear();
+
+    // Setup default mock returns
+    vi.mocked(useAtomValue).mockImplementation((atom) => {
+      const atomString = atom.toString();
+      switch (atomString) {
+        case "songNameAtom":
+          return "Bohemian Rhapsody";
+        case "artistAtom":
+          return "Queen";
+        case "albumAtom":
+          return "A Night at the Opera";
+        case "durationAtom":
+          return 355;
+        case "currentTimeAtom":
+          return 0;
+        default:
+          return undefined;
+      }
+    });
+  });
+
+  it("displays lyrics when successfully loaded", async () => {
+    const mockLyrics =
+      "[00:00.00] Is this the real life?\\n[00:05.00] Is this just fantasy?";
+    const mockParsedLyrics = {
+      lines: [
+        {
+          startTime: 0,
+          words: [{ text: "Is this the real life?", startTime: 0 }],
+        },
+        {
+          startTime: 5,
+          words: [{ text: "Is this just fantasy?", startTime: 5 }],
+        },
+      ],
+    };
+
+    vi.mocked(useLyricsFromSource).mockReturnValue(
+      createMockQueryResult({
+        data: mockLyrics,
+        isLoading: false,
+        isFetching: false,
+        isSuccess: true,
+        status: "success",
+        fetchStatus: "idle",
+        isFetched: true,
+        isFetchedAfterMount: true,
+      }),
+    );
+
+    // Mock the liricle instance methods
+    mockLiricleInstance.on.mockImplementation(
+      (event: string, callback: (data: unknown) => void) => {
+        if (event === "load") {
+          // Simulate calling the load callback immediately
+          setTimeout(() => callback(mockParsedLyrics), 0);
+        }
+      },
+    );
+
+    render(
+      <Provider>
+        <LyricsProvider />
+      </Provider>,
+    );
+
+    await waitFor(() => {
+      expect(screen.getByTestId("lyrics-content")).toBeInTheDocument();
+      expect(screen.getByText("Lyrics loaded")).toBeInTheDocument();
+    });
+
+    expect(useLyricsFromSource).toHaveBeenCalledWith({
+      name: "Bohemian Rhapsody",
+      artist: "Queen",
+      album: "A Night at the Opera",
+      duration: 355,
+      currentTime: 0,
+      isPlaying: false,
+    });
+  });
+
+  it("displays no lyrics found when data is null", async () => {
+    vi.mocked(useLyricsFromSource).mockReturnValue(
+      createMockQueryResult({
+        data: undefined,
+        isLoading: false,
+        isFetching: false,
+        isSuccess: true,
+        status: "success",
+        fetchStatus: "idle",
+        isFetched: true,
+        isFetchedAfterMount: true,
+      }),
+    );
+
+    render(
+      <Provider>
+        <LyricsProvider />
+      </Provider>,
+    );
+
+    await waitFor(
+      () => {
+        expect(screen.getByTestId("no-lyrics")).toBeInTheDocument();
+      },
+      { timeout: 1000 },
+    );
+  });
+
+  it("handles loading state", () => {
+    vi.mocked(useLyricsFromSource).mockReturnValue(
+      createMockQueryResult({
+        data: undefined,
+        isLoading: true,
+        isFetching: false,
+        isSuccess: false,
+        isPending: true,
+        status: "pending",
+        fetchStatus: "fetching",
+        isInitialLoading: true,
+      }),
+    );
+
+    render(
+      <Provider>
+        <LyricsProvider />
+      </Provider>,
+    );
+
+    expect(screen.getByText("Loading lyrics...")).toBeInTheDocument();
+    expect(screen.queryByTestId("no-lyrics")).not.toBeInTheDocument();
+  });
+});
diff --git a/client/src/test/Player.test.tsx b/client/src/test/Player.test.tsx
new file mode 100644
index 0000000..3bc8843
--- /dev/null
+++ b/client/src/test/Player.test.tsx
@@ -0,0 +1,181 @@
+import { describe, it, expect, vi, beforeEach } from "vitest";
+import { render, screen, fireEvent } from "@testing-library/react";
+import { Provider } from "jotai";
+
+// Mock the atoms first
+vi.mock("@/atoms/playerAtoms", () => ({
+  currentTimeAtom: { toString: () => "currentTimeAtom" },
+  durationAtom: { toString: () => "durationAtom" },
+  isPlayingAtom: { toString: () => "isPlayingAtom" },
+  songNameAtom: { toString: () => "songNameAtom" },
+  artistAtom: { toString: () => "artistAtom" },
+  playAtom: { toString: () => "playAtom" },
+  pauseAtom: { toString: () => "pauseAtom" },
+  seekAtom: { toString: () => "seekAtom" },
+  isDraggingAtom: { toString: () => "isDraggingAtom" },
+}));
+
+// Mock jotai hooks
+vi.mock("jotai", async () => {
+  const actual = await vi.importActual("jotai");
+  return {
+    ...actual,
+    useAtomValue: vi.fn(),
+    useSetAtom: vi.fn(),
+  };
+});
+
+// Mock the AnimatedSongName component
+vi.mock("../components/LyricsVisualizer/AnimatedSongName", () => ({
+  default: ({ songName }: { songName: string }) => (
+    <div data-testid="animated-song-name">{songName} -</div>
+  ),
+}));
+
+import Player from "../components/LyricsVisualizer/Player";
+import { useAtomValue, useSetAtom } from "jotai";
+
+describe("Player", () => {
+  const mockPlay = vi.fn();
+  const mockPause = vi.fn();
+  const mockSeek = vi.fn();
+
+  beforeEach(() => {
+    vi.clearAllMocks();
+
+    // Setup mock implementations
+    vi.mocked(useAtomValue).mockImplementation((atom) => {
+      const atomString = atom.toString();
+      switch (atomString) {
+        case "currentTimeAtom":
+          return 120;
+        case "durationAtom":
+          return 300;
+        case "isPlayingAtom":
+          return false;
+        case "songNameAtom":
+          return "Bohemian Rhapsody";
+        case "artistAtom":
+          return "Queen";
+        case "isDraggingAtom":
+          return false;
+        default:
+          return undefined;
+      }
+    });
+
+    vi.mocked(useSetAtom).mockImplementation((atom) => {
+      const atomString = atom.toString();
+      switch (atomString) {
+        case "playAtom":
+          return mockPlay;
+        case "pauseAtom":
+          return mockPause;
+        case "seekAtom":
+          return mockSeek;
+        default:
+          return vi.fn();
+      }
+    });
+  });
+
+  it("renders song information correctly", () => {
+    render(
+      <Provider>
+        <Player />
+      </Provider>,
+    );
+
+    expect(screen.getByTestId("animated-song-name")).toHaveTextContent(
+      "Bohemian Rhapsody -",
+    );
+    expect(screen.getByText("2:00")).toBeInTheDocument(); // current time
+    expect(screen.getByText("5:00")).toBeInTheDocument(); // duration
+  });
+
+  it("shows play button when not playing", () => {
+    render(
+      <Provider>
+        <Player />
+      </Provider>,
+    );
+
+    const playButton = screen.getByRole("button", { name: "Play" });
+    expect(playButton).toBeInTheDocument();
+  });
+
+  it("shows pause button when playing", () => {
+    vi.mocked(useAtomValue).mockImplementation((atom) => {
+      const atomString = atom.toString();
+      if (atomString === "isPlayingAtom") return true;
+      switch (atomString) {
+        case "currentTimeAtom":
+          return 120;
+        case "durationAtom":
+          return 300;
+        case "songNameAtom":
+          return "Bohemian Rhapsody";
+        case "artistAtom":
+          return "Queen";
+        case "isDraggingAtom":
+          return false;
+        default:
+          return undefined;
+      }
+    });
+
+    render(
+      <Provider>
+        <Player />
+      </Provider>,
+    );
+
+    const pauseButton = screen.getByRole("button", { name: "Pause" });
+    expect(pauseButton).toBeInTheDocument();
+  });
+
+  it("calls play function when play button is clicked", () => {
+    render(
+      <Provider>
+        <Player />
+      </Provider>,
+    );
+
+    const playButton = screen.getByRole("button", { name: "Play" });
+    fireEvent.click(playButton);
+
+    expect(mockPlay).toHaveBeenCalledTimes(1);
+  });
+
+  it("calls pause function when pause button is clicked", () => {
+    vi.mocked(useAtomValue).mockImplementation((atom) => {
+      const atomString = atom.toString();
+      if (atomString === "isPlayingAtom") return true;
+      switch (atomString) {
+        case "currentTimeAtom":
+          return 120;
+        case "durationAtom":
+          return 300;
+        case "songNameAtom":
+          return "Bohemian Rhapsody";
+        case "artistAtom":
+          return "Queen";
+        case "isDraggingAtom":
+          return false;
+        default:
+          return undefined;
+      }
+    });
+
+    render(
+      <Provider>
+        <Player />
+      </Provider>,
+    );
+
+    const pauseButton = screen.getByRole("button", { name: "Pause" });
+    fireEvent.click(pauseButton);
+
+    expect(mockPause).toHaveBeenCalledTimes(1);
+  });
+});
diff --git a/client/src/test/httpLyricsProvider.test.ts b/client/src/test/httpLyricsProvider.test.ts
new file mode 100644
index 0000000..c97fccb
--- /dev/null
+++ b/client/src/test/httpLyricsProvider.test.ts
@@ -0,0 +1,126 @@
+import { describe, it, expect, vi, beforeEach } from "vitest";
+import { HttpLyricsProvider } from "../providers/httpLyricsProvider";
+import type { Song } from "@/lib/api";
+
+// Mock the fetch function
+const mockFetch = vi.fn();
+global.fetch = mockFetch;
+
+describe("HttpLyricsProvider", () => {
+  let provider: HttpLyricsProvider;
+  const mockSong: Song = {
+    name: "Bohemian Rhapsody",
+    artist: "Queen",
+    album: "A Night at the Opera",
+    currentTime: 0,
+    duration: 355,
+    isPlaying: true,
+  };
+
+  beforeEach(() => {
+    provider = new HttpLyricsProvider();
+    vi.clearAllMocks();
+  });
+
+  describe("getLyrics", () => {
+    it("should return lyrics from local server when available", async () => {
+      const mockLyrics = "[00:00.00] Is this the real life?";
+      mockFetch.mockResolvedValueOnce({
+        ok: true,
+        text: () => Promise.resolve(mockLyrics),
+      } as Response);
+
+      const result = await provider.getLyrics(mockSong);
+
+      expect(result).toBe(mockLyrics);
+      expect(mockFetch).toHaveBeenCalledWith("http://127.0.0.1:4000/lyrics");
+    });
+
+    it("should fallback to LrcLib API when local server fails", async () => {
+      const mockLrcLibResponse = [
+        {
+          id: 1,
+          trackName: "Bohemian Rhapsody",
+          artistName: "Queen",
+          albumName: "A Night at the Opera",
+          duration: 355,
+          instrumental: false,
+          syncedLyrics: "[00:00.00] Is this the real life?",
+          plainLyrics: "Is this the real life?",
+        },
+      ];
+
+      // First call (local server) fails
+      mockFetch.mockRejectedValueOnce(new Error("Local server unavailable"));
+
+      // Second call (LrcLib) succeeds
+      mockFetch.mockResolvedValueOnce({
+        ok: true,
+        json: () => Promise.resolve(mockLrcLibResponse),
+      } as Response);
+
+      const result = await provider.getLyrics(mockSong);
+
+      expect(result).toBe(mockLrcLibResponse[0].syncedLyrics);
+      expect(mockFetch).toHaveBeenCalledTimes(2);
+      expect(mockFetch).toHaveBeenNthCalledWith(
+        1,
+        "http://127.0.0.1:4000/lyrics",
+      );
+      expect(mockFetch).toHaveBeenNthCalledWith(
+        2,
+        expect.stringContaining("https://lrclib.net/api/search"),
+      );
+    });
+
+    it("should return null when both sources fail", async () => {
+      mockFetch.mockRejectedValue(new Error("Network error"));
+
+      const result = await provider.getLyrics(mockSong);
+
+      expect(result).toBeNull();
+      expect(mockFetch).toHaveBeenCalledTimes(2);
+    });
+
+    it("should prefer synced lyrics over plain lyrics from LrcLib", async () => {
+      const mockLrcLibResponse = [
+        {
+          id: 1,
+          trackName: "Bohemian Rhapsody",
+          artistName: "Queen",
+          albumName: "A Night at the Opera",
+          duration: 355,
+          instrumental: false,
+          syncedLyrics: "[00:00.00] Synced lyrics",
+          plainLyrics: "Plain lyrics",
+        },
+      ];
+
+      mockFetch.mockRejectedValueOnce(new Error("Local server unavailable"));
+      mockFetch.mockResolvedValueOnce({
+        ok: true,
+        json: () => Promise.resolve(mockLrcLibResponse),
+      } as Response);
+
+      const result = await provider.getLyrics(mockSong);
+
+      expect(result).toBe(mockLrcLibResponse[0].syncedLyrics);
+    });
+
+    it("should handle empty song data", async () => {
+      const emptySong: Song = {
+        name: "",
+        artist: "",
+        album: "",
+        currentTime: 0,
+        duration: 0,
+        isPlaying: false,
+      };
+
+      const result = await provider.getLyrics(emptySong);
+
+      expect(result).toBeNull();
+      expect(mockFetch).not.toHaveBeenCalled();
+    });
+  });
+});
diff --git a/client/src/test/setup.test.ts b/client/src/test/setup.test.ts
new file mode 100644
index 0000000..2ec2d7e
--- /dev/null
+++ b/client/src/test/setup.test.ts
@@ -0,0 +1,13 @@
+import { describe, it, expect } from "vitest";
+
+describe("Test Setup", () => {
+  it("should run basic tests", () => {
+    expect(1 + 1).toBe(2);
+  });
+
+  it("should have vitest globals available", () => {
+    expect(typeof describe).toBe("function");
+    expect(typeof it).toBe("function");
+    expect(typeof expect).toBe("function");
+  });
+});
diff --git a/client/src/test/setup.ts b/client/src/test/setup.ts
new file mode 100644
index 0000000..46f907c
--- /dev/null
+++ b/client/src/test/setup.ts
@@ -0,0 +1,34 @@
+import { vi } from "vitest";
+import "@testing-library/jest-dom";
+
+// Mock fetch globally
+global.fetch = vi.fn();
+
+// Mock ResizeObserver
+global.ResizeObserver = vi.fn().mockImplementation(() => ({
+  observe: vi.fn(),
+  unobserve: vi.fn(),
+  disconnect: vi.fn(),
+}));
+
+// Mock IntersectionObserver
+global.IntersectionObserver = vi.fn().mockImplementation(() => ({
+  observe: vi.fn(),
+  unobserve: vi.fn(),
+  disconnect: vi.fn(),
+}));
+
+// Mock matchMedia
+Object.defineProperty(window, "matchMedia", {
+  writable: true,
+  value: vi.fn().mockImplementation((query: string) => ({
+    matches: false,
+    media: query,
+    onchange: null,
+    addListener: vi.fn(), // deprecated
+    removeListener: vi.fn(), // deprecated
+    addEventListener: vi.fn(),
+    removeEventListener: vi.fn(),
+    dispatchEvent: vi.fn(),
+  })),
+});
diff --git a/client/src/test/utils.test.ts b/client/src/test/utils.test.ts
new file mode 100644
index 0000000..2d0dc85
--- /dev/null
+++ b/client/src/test/utils.test.ts
@@ -0,0 +1,56 @@
+import { describe, it, expect } from "vitest";
+import { formatTime, cn } from "../lib/utils";
+
+describe("Utils", () => {
+  describe("formatTime", () => {
+    it("formats seconds correctly", () => {
+      expect(formatTime(0)).toBe("0:00");
+      expect(formatTime(30)).toBe("0:30");
+      expect(formatTime(60)).toBe("1:00");
+      expect(formatTime(90)).toBe("1:30");
+      expect(formatTime(3661)).toBe("61:01");
+    });
+
+    it("pads seconds with leading zero", () => {
+      expect(formatTime(65)).toBe("1:05");
+      expect(formatTime(125)).toBe("2:05");
+    });
+
+    it("handles edge cases", () => {
+      expect(formatTime(NaN)).toBe("0:00");
+      expect(formatTime(null as unknown as number)).toBe("0:00");
+      expect(formatTime(undefined as unknown as number)).toBe("0:00");
+    });
+
+    it("handles large numbers", () => {
+      expect(formatTime(7200)).toBe("120:00"); // 2 hours
+      expect(formatTime(7261)).toBe("121:01"); // 2 hours 1 minute 1 second
+    });
+  });
+
+  describe("cn (className utility)", () => {
+    it("merges class names correctly", () => {
+      expect(cn("px-2", "py-1")).toBe("px-2 py-1");
+    });
+
+    it("handles conditional classes", () => {
+      const isActive = true;
+      const isInactive = false;
+      expect(cn("base", isActive && "active", isInactive && "inactive")).toBe(
+        "base active",
+      );
+    });
+
+    it("handles Tailwind conflicts", () => {
+      // twMerge should resolve conflicts
+      expect(cn("px-2", "px-4")).toBe("px-4");
+      expect(cn("text-red-500", "text-blue-500")).toBe("text-blue-500");
+    });
+
+    it("handles empty inputs", () => {
+      expect(cn()).toBe("");
+      expect(cn("")).toBe("");
+      expect(cn(null, undefined, "")).toBe("");
+    });
+  });
+});
diff --git a/client/src/types/musicSource.ts b/client/src/types/musicSource.ts
index 4d2a874..4efbeb4 100644
--- a/client/src/types/musicSource.ts
+++ b/client/src/types/musicSource.ts
@@ -1,4 +1,4 @@
-import type { Song } from '@/lib/api'
+import type { Song } from "@/lib/api";
 
 /**
  * Interface for lyrics providers that can fetch lyrics for songs
@@ -9,37 +9,37 @@ export interface LyricsProvider {
    * @param song - The song to get lyrics for
    * @returns Promise with lyrics content or null if not found
    */
-  getLyrics(song: Song): Promise<string | null>
+  getLyrics(song: Song): Promise<string | null>;
 
   /**
    * Get the unique identifier for this provider
    */
-  getId(): string
+  getId(): string;
 
   /**
    * Get a human-readable name for this provider
    */
-  getName(): string
+  getName(): string;
 
   /**
    * Check if this provider supports the given song
    * @param song - The song to check
    */
-  supportsLyrics(song: Song): Promise<boolean>
+  supportsLyrics(song: Song): Promise<boolean>;
 
   /**
    * Check if this provider is currently available
    */
-  isAvailable(): Promise<boolean>
+  isAvailable(): Promise<boolean>;
 }
 
 /**
  * Configuration for lyrics providers
  */
 export interface LyricsProviderConfig {
-  type: 'http' | 'simulated' | 'lrclib' | 'genius'
-  name: string
-  options?: Record<string, any>
+  type: "http" | "simulated" | "lrclib" | "genius";
+  name: string;
+  options?: Record<string, unknown>;
 }
 
 /**
@@ -51,22 +51,22 @@ export interface ArtworkProvider {
    * @param song - The song to get artwork for
    * @returns Promise with array of artwork URLs
    */
-  getArtwork(song: Song): Promise<string[]>
+  getArtwork(song: Song): Promise<string[]>;
 
   /**
    * Get the unique identifier for this provider
    */
-  getId(): string
+  getId(): string;
 
   /**
    * Get a human-readable name for this provider
    */
-  getName(): string
+  getName(): string;
 
   /**
    * Check if this provider is currently available
    */
-  isAvailable(): Promise<boolean>
+  isAvailable(): Promise<boolean>;
 }
 
 /**
@@ -76,65 +76,65 @@ export interface MusicSource {
   /**
    * Get current song information and playback state
    */
-  getSong(): Promise<Song>
+  getSong(): Promise<Song>;
 
   /**
    * Start or resume playback
    */
-  play(): Promise<void>
+  play(): Promise<void>;
 
   /**
    * Pause playback
    */
-  pause(): Promise<void>
+  pause(): Promise<void>;
 
   /**
    * Seek to a specific time position
    * @param time - Time in seconds
    */
-  seek(time: number): Promise<void>
+  seek(time: number): Promise<void>;
 
   /**
    * Get the unique identifier for this source
    */
-  getId(): string
+  getId(): string;
 
   /**
    * Get a human-readable name for this source
    */
-  getName(): string
+  getName(): string;
 
   /**
    * Check if this source is currently available/connected
    */
-  isAvailable(): Promise<boolean>
+  isAvailable(): Promise<boolean>;
 
   /**
    * Get the lyrics provider associated with this source
    */
-  getLyricsProvider(): LyricsProvider | null
+  getLyricsProvider(): LyricsProvider | null;
 
   /**
    * Get the artwork provider associated with this source
    */
-  getArtworkProvider(): ArtworkProvider | null
+  getArtworkProvider(): ArtworkProvider | null;
 }
 
 /**
  * Result type for source operations
  */
 export interface SourceOperationResult {
-  success: boolean
-  error?: string
+  success: boolean;
+  error?: string;
 }
 
 /**
  * Configuration for music sources with plugin support
  */
 export interface SourceConfig {
-  type: 'http' | 'simulated'
-  name: string
-  options?: Record<string, any>
-  lyricsProvider?: LyricsProviderConfig
-  artworkProvider?: LyricsProviderConfig
-}
\ No newline at end of file
+  type: "http" | "simulated";
+  name: string;
+  options?: Record<string, unknown>;
+  lyricsProvider?: LyricsProviderConfig;
+  artworkProvider?: LyricsProviderConfig;
+}
diff --git a/client/tests/app.spec.ts b/client/tests/app.spec.ts
new file mode 100644
index 0000000..320b106
--- /dev/null
+++ b/client/tests/app.spec.ts
@@ -0,0 +1,232 @@
+import { test, expect } from "@playwright/test";
+
+test.describe("Application Layout and Responsiveness", () => {
+  test.beforeEach(async ({ page }) => {
+    // Mock lyrics API for simulated songs
+    await page.route("**/get*", async (route) => {
+      await route.fulfill({
+        status: 200,
+        contentType: "application/json",
+        body: JSON.stringify({
+          syncType: "LINE_SYNCED",
+          lines: [
+            { startTimeMs: 0, words: "Is this the real life?" },
+            { startTimeMs: 15000, words: "Is this just fantasy?" },
+            { startTimeMs: 30000, words: "Caught in a landslide" },
+            { startTimeMs: 45000, words: "No escape from reality" },
+          ],
+        }),
+      });
+    });
+
+    await page.goto("/");
+
+    // Wait for the React app to load and the simulated player to initialize
+    await page.waitForTimeout(1000);
+  });
+
+  test.describe("Portrait Layout (Mobile)", () => {
+    test.beforeEach(async ({ page }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+    });
+
+    test("should load the application successfully", async ({ page }) => {
+      // Main app container should be visible
+      await expect(page.locator("#root")).toBeVisible();
+
+      // Wait for React to render completely
+      await page.waitForTimeout(3000);
+
+      // Try to find the element with a longer timeout
+      await page.waitForSelector('[data-testid="lyrics-visualizer"]', {
+        timeout: 15000,
+        state: "visible",
+      });
+
+      // Should have the main visualizer component
+      await expect(
+        page.locator('[data-testid="lyrics-visualizer"]'),
+      ).toBeVisible();
+    });
+
+    test("should display all main components in portrait", async ({ page }) => {
+      // Player should be visible
+      await expect(page.locator('[data-testid="player"]')).toBeVisible();
+
+      // Lyrics display should be visible
+      await expect(
+        page.locator('[data-testid="lyrics-display"]'),
+      ).toBeVisible();
+
+      // Should show the simulated song info
+      await expect(page.locator('[data-testid="song-name"]')).toContainText(
+        "Bohemian Rhapsody",
+      );
+      await expect(page.locator('[data-testid="artist-name"]')).toContainText(
+        "Queen",
+      );
+    });
+
+    test("should handle scroll behavior correctly", async ({ page }) => {
+      // Page should be scrollable if content exceeds viewport
+      const body = page.locator("body");
+      await expect(body).toBeVisible();
+
+      // Should not have horizontal scroll
+      const scrollWidth = await page.evaluate(() => document.body.scrollWidth);
+      const clientWidth = await page.evaluate(() => document.body.clientWidth);
+      expect(scrollWidth).toBeLessThanOrEqual(clientWidth + 5); // Allow small margin for rounding
+    });
+  });
+
+  test.describe("Landscape Layout (Desktop/Tablet)", () => {
+    test.beforeEach(async ({ page }) => {
+      await page.setViewportSize({ width: 1024, height: 768 });
+    });
+
+    test("should adapt layout for landscape orientation", async ({ page }) => {
+      // Main components should still be visible
+      await expect(
+        page.locator('[data-testid="lyrics-visualizer"]'),
+      ).toBeVisible();
+      await expect(page.locator('[data-testid="player"]')).toBeVisible();
+      await expect(
+        page.locator('[data-testid="lyrics-display"]'),
+      ).toBeVisible();
+    });
+
+    test("should optimize space usage in landscape", async ({ page }) => {
+      // The layout should make good use of horizontal space
+      const visualizer = page.locator('[data-testid="lyrics-visualizer"]');
+      const visualizerBox = await visualizer.boundingBox();
+
+      expect(visualizerBox?.width).toBeGreaterThan(800); // Should use most of the width
+    });
+
+    test("should maintain aspect ratios in landscape", async ({ page }) => {
+      // Album artwork or other visual elements should maintain proper proportions
+      const aspectRatio = page.locator('[data-testid="album-artwork"]');
+      if (await aspectRatio.isVisible()) {
+        const box = await aspectRatio.boundingBox();
+        if (box) {
+          // Square aspect ratio for album artwork
+          expect(Math.abs(box.width - box.height)).toBeLessThan(5);
+        }
+      }
+    });
+  });
+
+  test.describe("Responsive Transitions", () => {
+    test("should handle orientation changes smoothly", async ({ page }) => {
+      // Start in portrait
+      await page.setViewportSize({ width: 768, height: 1024 });
+      await page.waitForSelector('[data-testid="lyrics-visualizer"]');
+
+      // Rotate to landscape
+      await page.setViewportSize({ width: 1024, height: 768 });
+
+      // Main components should still work
+      await expect(
+        page.locator('[data-testid="lyrics-visualizer"]'),
+      ).toBeVisible();
+      await expect(page.locator('[data-testid="player"]')).toBeVisible();
+
+      // Rotate back to portrait
+      await page.setViewportSize({ width: 768, height: 1024 });
+
+      // Should still be functional
+      await expect(
+        page.locator('[data-testid="lyrics-visualizer"]'),
+      ).toBeVisible();
+      await expect(page.locator('[data-testid="player"]')).toBeVisible();
+    });
+
+    test("should handle different screen sizes", async ({ page }) => {
+      const viewports = [
+        { width: 320, height: 568 }, // iPhone SE
+        { width: 375, height: 667 }, // iPhone 8
+        { width: 768, height: 1024 }, // iPad Portrait
+        { width: 1024, height: 768 }, // iPad Landscape
+        { width: 1440, height: 900 }, // Desktop
+      ];
+
+      for (const viewport of viewports) {
+        await page.setViewportSize(viewport);
+
+        // Main app should be visible and functional
+        await expect(
+          page.locator('[data-testid="lyrics-visualizer"]'),
+        ).toBeVisible();
+
+        // Should not have horizontal scroll
+        const scrollWidth = await page.evaluate(
+          () => document.body.scrollWidth,
+        );
+        const clientWidth = await page.evaluate(
+          () => document.body.clientWidth,
+        );
+        expect(scrollWidth).toBeLessThanOrEqual(clientWidth + 10);
+      }
+    });
+  });
+
+  test.describe("Performance and Loading", () => {
+    test("should load quickly", async ({ page }) => {
+      const startTime = Date.now();
+
+      await page.goto("/");
+      await page.waitForSelector('[data-testid="lyrics-visualizer"]');
+
+      const loadTime = Date.now() - startTime;
+      expect(loadTime).toBeLessThan(5000); // Should load within 5 seconds
+    });
+  });
+
+  test.describe("Accessibility", () => {
+    test("should have proper focus management", async ({ page }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+
+      // Get all interactive elements
+      const interactiveElements = [
+        '[data-testid="play-pause-button"]',
+        '[data-testid="progress-slider"]',
+        'button[aria-label="Search lyrics"]',
+        'button[aria-label="View playlists"]',
+      ];
+
+      // Tab through and verify at least one element can be focused
+      let foundFocusableElement = false;
+      for (let i = 0; i < interactiveElements.length + 1; i++) {
+        await page.keyboard.press("Tab");
+
+        // Check if any of our interactive elements is focused
+        for (const selector of interactiveElements) {
+          const element = page.locator(selector);
+          if (
+            (await element.isVisible()) &&
+            (await element.evaluate((el) => document.activeElement === el))
+          ) {
+            foundFocusableElement = true;
+            break;
+          }
+        }
+        if (foundFocusableElement) break;
+      }
+
+      expect(foundFocusableElement).toBe(true);
+    });
+
+    test("should have adequate color contrast", async ({ page }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+
+      // Check that text is visible (basic contrast check)
+      const songTitle = page.locator('[data-testid="song-title"]');
+      if (await songTitle.isVisible()) {
+        const color = await songTitle.evaluate(
+          (el) => getComputedStyle(el).color,
+        );
+        expect(color).not.toBe("rgba(0, 0, 0, 0)"); // Should not be transparent
+      }
+    });
+  });
+});
diff --git a/client/tests/lyrics.spec.ts b/client/tests/lyrics.spec.ts
new file mode 100644
index 0000000..d0ae974
--- /dev/null
+++ b/client/tests/lyrics.spec.ts
@@ -0,0 +1,255 @@
+import { test, expect } from "@playwright/test";
+
+test.describe("Lyrics Display", () => {
+  test.beforeEach(async ({ page }) => {
+    // Mock lyrics API for simulated songs
+    await page.route("**/get*", async (route) => {
+      await route.fulfill({
+        status: 200,
+        contentType: "application/json",
+        body: JSON.stringify({
+          syncType: "LINE_SYNCED",
+          lines: [
+            { startTimeMs: 0, words: "Is this the real life?" },
+            { startTimeMs: 15000, words: "Is this just fantasy?" },
+            { startTimeMs: 30000, words: "Caught in a landslide" },
+            { startTimeMs: 45000, words: "No escape from reality" },
+          ],
+        }),
+      });
+    });
+
+    await page.goto("/");
+
+    // Wait longer for the simulated player to start and lyrics to load
+    await page.waitForSelector('[data-testid="lyrics-display"]', {
+      timeout: 15000,
+    });
+
+    // Wait for the player to be initialized and playing
+    await page.waitForFunction(
+      () => {
+        const songName = document.querySelector('[data-testid="song-name"]');
+        return songName && songName.textContent?.includes("Bohemian Rhapsody");
+      },
+      { timeout: 10000 },
+    );
+
+    // Additional wait for lyrics to process and render
+    await page.waitForTimeout(2000);
+  });
+
+  test.describe("Portrait Mode - Lyrics", () => {
+    test.beforeEach(async ({ page }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+    });
+
+    test("should display synchronized lyrics", async ({ page }) => {
+      // Wait for lyrics to load
+      await page.waitForSelector('[data-testid="lyrics-line"]', {
+        timeout: 15000,
+      });
+
+      const lyricsLines = page.locator('[data-testid="lyrics-line"]');
+      const lineCount = await lyricsLines.count();
+
+      expect(lineCount).toBeGreaterThan(10); // Should have at least 10 lines
+
+      // Check first line content matches Bohemian Rhapsody
+      await expect(lyricsLines.first()).toContainText("Is this the real life?");
+    });
+
+    test("should highlight current lyrics line", async ({ page }) => {
+      // Wait for lyrics to load
+      await page.waitForSelector('[data-testid="lyrics-line"]');
+
+      // Click play to start playback and lyrics synchronization
+      const playButton = page.locator('[data-testid="play-pause-button"]');
+      await playButton.click();
+
+      // Wait for at least one line to be marked as current
+      await page.waitForSelector(
+        '[data-testid="lyrics-line"][data-current="true"]',
+        {
+          timeout: 10000,
+        },
+      );
+
+      const currentLine = page.locator(
+        '[data-testid="lyrics-line"][data-current="true"]',
+      );
+      await expect(currentLine).toBeVisible();
+      // Should contain the first line since player starts at 0:00
+      await expect(currentLine).toContainText("Is this the real life?");
+    });
+
+    test("should scroll to current lyrics line", async ({ page }) => {
+      // Wait for lyrics to load
+      await page.waitForSelector('[data-testid="lyrics-container"]');
+
+      const lyricsContainer = page.locator('[data-testid="lyrics-container"]');
+      await expect(lyricsContainer).toBeVisible();
+
+      // Click play to start playback and lyrics synchronization
+      const playButton = page.locator('[data-testid="play-pause-button"]');
+      await playButton.click();
+
+      // Wait for current line to be marked and visible in viewport
+      await page.waitForSelector(
+        '[data-testid="lyrics-line"][data-current="true"]',
+        {
+          timeout: 10000,
+        },
+      );
+
+      const currentLine = page.locator(
+        '[data-testid="lyrics-line"][data-current="true"]',
+      );
+      await expect(currentLine).toBeInViewport();
+    });
+  });
+
+  test.describe("Landscape Mode - Lyrics", () => {
+    test.beforeEach(async ({ page }) => {
+      await page.setViewportSize({ width: 1024, height: 768 });
+    });
+
+    test("should display lyrics in landscape layout", async ({ page }) => {
+      await page.waitForSelector('[data-testid="lyrics-line"]');
+
+      const lyricsLines = page.locator('[data-testid="lyrics-line"]');
+      const lineCount = await lyricsLines.count();
+      expect(lineCount).toBeGreaterThan(10); // Should have many lines for Bohemian Rhapsody
+    });
+
+    test("should maintain lyrics synchronization in landscape", async ({
+      page,
+    }) => {
+      await page.waitForSelector('[data-testid="lyrics-line"]');
+
+      // Click play to start playback and lyrics synchronization
+      const playButton = page.locator('[data-testid="play-pause-button"]');
+      await playButton.click();
+
+      // Wait for current line to be marked and highlighted
+      await page.waitForSelector(
+        '[data-testid="lyrics-line"][data-current="true"]',
+        {
+          timeout: 10000,
+        },
+      );
+
+      const currentLine = page.locator(
+        '[data-testid="lyrics-line"][data-current="true"]',
+      );
+      await expect(currentLine).toBeVisible();
+      await expect(currentLine).toContainText("Is this the real life?"); // First line at start
+    });
+  });
+
+  test.describe("Source Switching", () => {
+    test("should show source switcher when multiple sources available", async ({
+      page,
+    }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+
+      // Source switcher should be visible
+      const sourceSwitcher = page.locator('[data-testid="source-switcher"]');
+      await expect(sourceSwitcher).toBeVisible();
+    });
+
+    test("should allow switching between lyrics sources", async ({ page }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+
+      const sourceSwitcher = page.locator('[data-testid="source-switcher"]');
+      if (await sourceSwitcher.isVisible()) {
+        // Click to expand source options
+        await sourceSwitcher.click();
+
+        // Should show available sources
+        const sourceOptions = page.locator('[data-testid="source-option"]');
+        await expect(sourceOptions.first()).toBeVisible();
+      }
+    });
+  });
+
+  test.describe("No Lyrics State", () => {
+    // Note: These tests are skipped because the simulated player always has lyrics
+    // for its hardcoded playlist songs and doesn't make HTTP requests that can be mocked
+    test.skip("should handle songs without lyrics", async ({ page }) => {
+      // Clear any existing route mocks
+      await page.unroute("**/get*");
+
+      // Mock no lyrics response
+      await page.route("**/get*", async (route) => {
+        await route.fulfill({
+          status: 404,
+          contentType: "application/json",
+          body: JSON.stringify({ error: "Not found" }),
+        });
+      });
+
+      await page.goto("/");
+
+      // Should show no lyrics message
+      await expect(
+        page.locator('[data-testid="no-lyrics-message"]'),
+      ).toBeVisible();
+    });
+
+    test.skip("should show fallback when lyrics fail to load", async ({
+      page,
+    }) => {
+      // Clear any existing route mocks
+      await page.unroute("**/get*");
+
+      // Mock lyrics API failure
+      await page.route("**/get*", async (route) => {
+        await route.fulfill({
+          status: 500,
+          contentType: "application/json",
+          body: JSON.stringify({ error: "Server error" }),
+        });
+      });
+
+      await page.goto("/");
+
+      // Wait for error state to appear
+      await page.waitForSelector('[data-testid="error-message"]', {
+        timeout: 10000,
+      });
+
+      // Should show error state
+      await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
+    });
+  });
+
+  test.describe("Visual Effects", () => {
+    test("should show background effects with album artwork", async ({
+      page,
+    }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+
+      // Background should be visible
+      const background = page.locator('[data-testid="lyrics-background"]');
+      await expect(background).toBeVisible();
+    });
+
+    test("should handle responsive design transitions", async ({ page }) => {
+      // Start in portrait
+      await page.setViewportSize({ width: 768, height: 1024 });
+      await page.waitForSelector('[data-testid="lyrics-display"]');
+
+      // Switch to landscape
+      await page.setViewportSize({ width: 1024, height: 768 });
+
+      // Lyrics should still be visible and functional
+      const lyricsDisplay = page.locator('[data-testid="lyrics-display"]');
+      await expect(lyricsDisplay).toBeVisible();
+
+      const lyricsLines = page.locator('[data-testid="lyrics-line"]');
+      const lineCount = await lyricsLines.count();
+      expect(lineCount).toBeGreaterThan(10); // Should have many lines for Bohemian Rhapsody
+    });
+  });
+});
diff --git a/client/tests/player.spec.ts b/client/tests/player.spec.ts
new file mode 100644
index 0000000..156bd67
--- /dev/null
+++ b/client/tests/player.spec.ts
@@ -0,0 +1,245 @@
+import { test, expect } from "@playwright/test";
+
+test.describe("Player Component", () => {
+  test.beforeEach(async ({ page }) => {
+    // Mock lyrics API for simulated songs
+    await page.route("**/get*", async (route) => {
+      await route.fulfill({
+        status: 200,
+        contentType: "application/json",
+        body: JSON.stringify({
+          syncType: "LINE_SYNCED",
+          lines: [
+            { startTimeMs: 0, words: "Is this the real life?" },
+            { startTimeMs: 15000, words: "Is this just fantasy?" },
+            { startTimeMs: 30000, words: "Caught in a landslide" },
+            { startTimeMs: 45000, words: "No escape from reality" },
+          ],
+        }),
+      });
+    });
+
+    await page.goto("/");
+
+    // Wait for the player to load
+    await page.waitForSelector('[data-testid="player"]', { timeout: 10000 });
+  });
+
+  test.describe("Portrait Mode", () => {
+    test.beforeEach(async ({ page }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+    });
+
+    test("should display song information correctly", async ({ page }) => {
+      await expect(page.locator('[data-testid="song-name"]')).toContainText(
+        "Bohemian Rhapsody",
+      );
+      await expect(page.locator('[data-testid="artist-name"]')).toContainText(
+        "Queen",
+      );
+    });
+
+    test("should show play/pause button and be clickable", async ({ page }) => {
+      const playPauseButton = page.locator('[data-testid="play-pause-button"]');
+      await expect(playPauseButton).toBeVisible();
+
+      // Simulated player starts paused, so should show play icon initially
+      await expect(
+        playPauseButton.locator('[data-testid="play-icon"]'),
+      ).toBeVisible();
+
+      // Click to play
+      await playPauseButton.click();
+
+      // Should show pause icon when playing
+      await expect(
+        playPauseButton.locator('[data-testid="pause-icon"]'),
+      ).toBeVisible();
+
+      // Click to pause again
+      await playPauseButton.click();
+
+      // Should show play icon when paused
+      await expect(
+        playPauseButton.locator('[data-testid="play-icon"]'),
+      ).toBeVisible();
+    });
+
+    test("should display progress slider and be interactive", async ({
+      page,
+    }) => {
+      const progressSlider = page.locator('[data-testid="progress-slider"]');
+      await expect(progressSlider).toBeVisible();
+
+      // Check if slider shows initial progress (should be 0 at start)
+      const sliderValue = await progressSlider.getAttribute("aria-valuenow");
+      expect(parseInt(sliderValue || "0")).toBe(0);
+
+      // Verify slider is interactive by checking it's not disabled
+      await expect(progressSlider).not.toBeDisabled();
+    });
+
+    test("should show current time and duration", async ({ page }) => {
+      await expect(page.locator('[data-testid="current-time"]')).toContainText(
+        "0:00",
+      );
+      await expect(page.locator('[data-testid="duration"]')).toContainText(
+        "5:55",
+      ); // Bohemian Rhapsody duration
+    });
+
+    test("should have animated song name", async ({ page }) => {
+      // The song name should be visible (Bohemian Rhapsody is the default)
+      const songName = page.locator('[data-testid="song-name"]');
+      await expect(songName).toBeVisible();
+      await expect(songName).toContainText("Bohemian Rhapsody");
+    });
+  });
+
+  test.describe("Landscape Mode", () => {
+    test.beforeEach(async ({ page }) => {
+      await page.setViewportSize({ width: 1024, height: 768 });
+    });
+
+    test("should display song information correctly in landscape", async ({
+      page,
+    }) => {
+      await expect(page.locator('[data-testid="song-name"]')).toContainText(
+        "Bohemian Rhapsody",
+      );
+      await expect(page.locator('[data-testid="artist-name"]')).toContainText(
+        "Queen",
+      );
+    });
+
+    test("should maintain play/pause functionality in landscape", async ({
+      page,
+    }) => {
+      const playPauseButton = page.locator('[data-testid="play-pause-button"]');
+      await expect(playPauseButton).toBeVisible();
+
+      // Simulated player starts paused, so should show play icon initially
+      await expect(
+        playPauseButton.locator('[data-testid="play-icon"]'),
+      ).toBeVisible();
+
+      // Click to play
+      await playPauseButton.click();
+
+      // Should show pause icon when playing
+      await expect(
+        playPauseButton.locator('[data-testid="pause-icon"]'),
+      ).toBeVisible();
+
+      // Click to pause again
+      await playPauseButton.click();
+
+      // Should show play icon when paused
+      await expect(
+        playPauseButton.locator('[data-testid="play-icon"]'),
+      ).toBeVisible();
+    });
+
+    test("should adapt layout for landscape orientation", async ({ page }) => {
+      // The player should be visible and functional in landscape
+      const player = page.locator('[data-testid="player"]');
+      await expect(player).toBeVisible();
+
+      // Progress slider should still be interactive
+      const progressSlider = page.locator('[data-testid="progress-slider"]');
+      await expect(progressSlider).toBeVisible();
+    });
+  });
+
+  test.describe("Player Interactions", () => {
+    test("should handle progress slider interaction", async ({ page }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+
+      const progressSlider = page.locator('[data-testid="progress-slider"]');
+      const currentTimeDisplay = page.locator('[data-testid="current-time"]');
+
+      // Get initial time (should be 0:00)
+      const initialTime = await currentTimeDisplay.textContent();
+      expect(initialTime).toBe("0:00");
+
+      // Get slider bounding box for interaction
+      const sliderBox = await progressSlider.boundingBox();
+      if (sliderBox) {
+        // Click at 75% of the slider (should seek to around 75% of 5:55 = ~4:26)
+        const clickX = sliderBox.x + sliderBox.width * 0.75;
+        const clickY = sliderBox.y + sliderBox.height / 2;
+
+        await page.mouse.click(clickX, clickY);
+
+        // Wait for the player to update and check the visual time display
+        await page.waitForTimeout(500);
+        const newTime = await currentTimeDisplay.textContent();
+
+        // The displayed time should have changed from initial and be > 4:00
+        expect(newTime).not.toBe(initialTime);
+        expect(newTime).not.toBe("0:00");
+
+        // Should be around 4:xx after clicking at 75%
+        const timeMatch = newTime?.match(/(\d+):(\d+)/);
+        if (timeMatch) {
+          const minutes = parseInt(timeMatch[1]);
+          expect(minutes).toBeGreaterThanOrEqual(4);
+        }
+      }
+    });
+
+    test("should display player controls", async ({ page }) => {
+      // Since we're using simulated source, just verify the main player is working
+      const player = page.locator('[data-testid="player"]');
+      await expect(player).toBeVisible();
+
+      // Should show song information
+      await expect(page.locator('[data-testid="song-name"]')).toContainText(
+        "Bohemian Rhapsody",
+      );
+      await expect(page.locator('[data-testid="artist-name"]')).toContainText(
+        "Queen",
+      );
+    });
+
+    test("should handle playback time progression when playing", async ({
+      page,
+    }) => {
+      await page.setViewportSize({ width: 768, height: 1024 });
+
+      const playButton = page.locator('[data-testid="play-pause-button"]');
+      const currentTimeDisplay = page.locator('[data-testid="current-time"]');
+
+      // Start playing
+      await playButton.click();
+
+      // Wait a bit for time to progress
+      await page.waitForTimeout(1500);
+
+      // Time should have progressed from 0:00
+      const currentTime = await currentTimeDisplay.textContent();
+      expect(currentTime).not.toBe("0:00");
+
+      // Should show seconds have passed
+      const timeMatch = currentTime?.match(/(\d+):(\d+)/);
+      if (timeMatch) {
+        const seconds = parseInt(timeMatch[1]) * 60 + parseInt(timeMatch[2]);
+        expect(seconds).toBeGreaterThan(0);
+      }
+    });
+  });
+
+  test.describe("Error Handling", () => {
+    test("should show player even without external dependencies", async ({
+      page,
+    }) => {
+      // The simulated player should work without external API calls
+      const player = page.locator('[data-testid="player"]');
+      await expect(player).toBeVisible();
+
+      // Should show play/pause button
+      const playPauseButton = page.locator('[data-testid="play-pause-button"]');
+      await expect(playPauseButton).toBeVisible();
+    });
+  });
+});
diff --git a/client/tests/visual.spec.ts b/client/tests/visual.spec.ts
deleted file mode 100644
index 5ba5779..0000000
--- a/client/tests/visual.spec.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-import { test, expect } from '@playwright/test';
-
-test('it should match the screenshot in portrait mode', async ({ page }) => {
-  await page.setViewportSize({ width: 768, height: 1024 });
-  await page.goto('/');
-
-  // Wait for the song name to be visible to ensure the player has loaded.
-  const songName = page.getByText('Bohemian Rhapsody');
-  await expect(songName).toBeVisible();
-
-  // Wait for a short period to allow animations to settle
-  await page.waitForTimeout(500);
-
-  await expect(page).toHaveScreenshot('home-page-portrait.png', { fullPage: true });
-});
-
-test('it should match the screenshot in landscape mode', async ({ page }) => {
-  await page.setViewportSize({ width: 1024, height: 768 });
-  await page.goto('/');
-
-  // Wait for the song name to be visible to ensure the player has loaded.
-  const songName = page.getByText('Bohemian Rhapsody');
-  await expect(songName).toBeVisible();
-
-  // Wait for a short period to allow animations to settle
-  await page.waitForTimeout(500);
-
-  await expect(page).toHaveScreenshot('home-page-landscape.png', { fullPage: true });
-});
\ No newline at end of file
diff --git a/client/vitest.config.ts b/client/vitest.config.ts
new file mode 100644
index 0000000..c243447
--- /dev/null
+++ b/client/vitest.config.ts
@@ -0,0 +1,19 @@
+import { defineConfig } from "vitest/config";
+import react from "@vitejs/plugin-react";
+import { resolve } from "path";
+
+export default defineConfig({
+  plugins: [react()],
+  test: {
+    globals: true,
+    environment: "jsdom",
+    setupFiles: ["./src/test/setup.ts"],
+    css: true,
+    exclude: ["**/node_modules/**", "**/tests/**"], // Exclude Playwright tests
+  },
+  resolve: {
+    alias: {
+      "@": resolve(__dirname, "./src"),
+    },
+  },
+});
diff --git a/package.json b/package.json
index 4166b5f..3f45da1 100644
--- a/package.json
+++ b/package.json
@@ -9,9 +9,17 @@
   "scripts": {
     "dev": "turbo dev",
     "build": "turbo build",
-    "lint": "turbo lint"
+    "test": "turbo test",
+    "lint": "turbo lint",
+    "lint:check": "turbo lint:check",
+    "format": "turbo format",
+    "format:check": "turbo format:check",
+    "prepare": "husky"
   },
   "devDependencies": {
+    "husky": "^9.1.7",
+    "prettier": "^3.6.2",
+    "prettier-plugin-tailwindcss": "^0.6.14",
     "turbo": "^2.0.9"
   }
 }
diff --git a/pnpm-workspace.yaml b/pnpm-workspace.yaml
index c43375c..3e82e7c 100644
--- a/pnpm-workspace.yaml
+++ b/pnpm-workspace.yaml
@@ -1,3 +1,3 @@
 packages:
-  - 'client'
-  - 'server'
+  - "client"
+  - "server"
diff --git a/server/package.json b/server/package.json
index e73b09b..f6a3967 100644
--- a/server/package.json
+++ b/server/package.json
@@ -3,23 +3,23 @@
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
+  "type": "commonjs",
   "scripts": {
     "dev": "ts-node-dev --respawn src/index.ts",
-    "build": "tsc src/index.ts",
-    "test": "echo \"Error: no test specified\" && exit 1"
+    "build": "tsc",
+    "format": "prettier --write ."
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
-  "type": "commonjs",
   "dependencies": {
     "@hono/node-server": "^1.15.0",
+    "hono": "^4.8.4"
+  },
+  "devDependencies": {
     "@types/node": "^24.0.13",
-    "hono": "^4.8.4",
     "ts-node": "^10.9.2",
+    "ts-node-dev": "^2.0.0",
     "typescript": "^5.8.3"
-  },
-  "devDependencies": {
-    "ts-node-dev": "^2.0.0"
   }
 }
diff --git a/server/src/index.js b/server/src/index.js
deleted file mode 100644
index 65da2a5..0000000
--- a/server/src/index.js
+++ /dev/null
@@ -1,167 +0,0 @@
-"use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
-    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (g && (g = 0, op[0] && (_ = 0)), _) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
-    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
-        if (ar || !(i in from)) {
-            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
-            ar[i] = from[i];
-        }
-    }
-    return to.concat(ar || Array.prototype.slice.call(from));
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var hono_1 = require("hono");
-var node_server_1 = require("@hono/node-server");
-var child_process_1 = require("child_process");
-var cors_1 = require("hono/cors");
-var app = new hono_1.Hono();
-app.use((0, cors_1.cors)());
-var scriptLines = [
-    'tell application "Music"',
-    "    set playerState to player state",
-    "    set currentTrack to current track",
-    "    set trackName to name of currentTrack",
-    "    set artistName to artist of currentTrack",
-    "    set albumName to album of currentTrack",
-    "    set currentTime to player position",
-    "    set totalTime to duration of currentTrack",
-    '    return trackName & "\n" & artistName & "\n" & albumName & "\n" & currentTime & "\n" & totalTime & "\n" & playerState',
-    "end tell",
-];
-var osascriptArgs = scriptLines.flatMap(function (line) { return ["-e", line]; });
-function getSongInfo() {
-    return new Promise(function (resolve) {
-        (0, child_process_1.execFile)("osascript", osascriptArgs, function (error, stdout, stderr) {
-            if (error || stderr) {
-                resolve({ error: "Not playing" });
-                return;
-            }
-            var output = stdout.trim();
-            console.log(output);
-            if (output === "No song playing") {
-                resolve({ message: "No song playing" });
-                return;
-            }
-            var _a = output.split("\n"), name = _a[0], artist = _a[1], album = _a[2], currentTime = _a[3], duration = _a[4], playerState = _a[5];
-            resolve({
-                name: name,
-                artist: artist,
-                album: album,
-                currentTime: currentTime,
-                duration: duration,
-                playerState: playerState,
-            });
-        });
-    });
-}
-app.get("/", function (c) { return c.text("Hello World"); });
-app.get("/music", function (c) { return __awaiter(void 0, void 0, void 0, function () {
-    var songInfo;
-    return __generator(this, function (_a) {
-        switch (_a.label) {
-            case 0: return [4 /*yield*/, getSongInfo()];
-            case 1:
-                songInfo = _a.sent();
-                if (songInfo.error) {
-                    return [2 /*return*/, c.json(songInfo, 404)];
-                }
-                return [2 /*return*/, c.json(songInfo)];
-        }
-    });
-}); });
-app.post("/music", function (c) { return __awaiter(void 0, void 0, void 0, function () {
-    var body, commands, playing, currentTime, scriptLines_1, osascriptArgs_1;
-    return __generator(this, function (_a) {
-        switch (_a.label) {
-            case 0: return [4 /*yield*/, c.req.json()];
-            case 1:
-                body = _a.sent();
-                commands = [];
-                // Handle new action-based format
-                if (body.action) {
-                    switch (body.action) {
-                        case "play":
-                            commands.push("play");
-                            break;
-                        case "pause":
-                            commands.push("pause");
-                            break;
-                        case "seek":
-                            if (body.time !== undefined) {
-                                commands.push("set player position to ".concat(body.time));
-                            }
-                            break;
-                    }
-                }
-                // Handle old format for backward compatibility
-                else {
-                    playing = body.playing, currentTime = body.currentTime;
-                    if (playing === true) {
-                        commands.push("play");
-                    }
-                    else if (playing === false) {
-                        commands.push("pause");
-                    }
-                    if (currentTime !== undefined) {
-                        commands.push("set player position to ".concat(currentTime));
-                    }
-                }
-                if (commands.length > 0) {
-                    scriptLines_1 = __spreadArray(__spreadArray([
-                        'tell application "Music"'
-                    ], commands.map(function (cmd) { return "    ".concat(cmd); }), true), [
-                        "end tell",
-                    ], false);
-                    osascriptArgs_1 = scriptLines_1.flatMap(function (line) { return ["-e", line]; });
-                    (0, child_process_1.execFile)("osascript", osascriptArgs_1, function (error, stdout, stderr) {
-                        if (error || stderr) {
-                            console.error("Error executing AppleScript: ".concat(error || stderr));
-                        }
-                        else {
-                            console.log("Music app command executed: ".concat(commands.join(", ")));
-                        }
-                    });
-                }
-                return [2 /*return*/, c.json({ message: "Music app command received" })];
-        }
-    });
-}); });
-(0, node_server_1.serve)({
-    fetch: app.fetch,
-    port: 4000,
-});
diff --git a/server/tsconfig.json b/server/tsconfig.json
index 904d43f..cedba57 100644
--- a/server/tsconfig.json
+++ b/server/tsconfig.json
@@ -11,7 +11,7 @@
     // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
 
     /* Language and Environment */
-    "target": "es2016",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
+    "target": "es2016" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
     // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
     // "jsx": "preserve",                                /* Specify what JSX code is generated. */
     // "libReplacement": true,                           /* Enable lib replacement. */
@@ -26,7 +26,7 @@
     // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
 
     /* Modules */
-    "module": "commonjs",                                /* Specify what module code is generated. */
+    "module": "commonjs" /* Specify what module code is generated. */,
     // "rootDir": "./",                                  /* Specify the root folder within your source files. */
     // "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
     // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
@@ -59,7 +59,8 @@
     // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
     // "noEmit": true,                                   /* Disable emitting files from a compilation. */
     // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
-    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
+    "outDir": "./dist" /* Specify an output folder for all emitted files. */,
+    "rootDir": "./src" /* Specify the root folder within your source files. */,
     // "removeComments": true,                           /* Disable emitting comments. */
     // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
     // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
@@ -80,12 +81,12 @@
     // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
     // "erasableSyntaxOnly": true,                       /* Do not allow runtime constructs that are not part of ECMAScript. */
     // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
-    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
+    "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */,
     // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
-    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */
+    "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,
 
     /* Type Checking */
-    "strict": true,                                      /* Enable all strict type-checking options. */
+    "strict": true /* Enable all strict type-checking options. */,
     // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
     // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
     // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
@@ -108,6 +109,6 @@
 
     /* Completeness */
     // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
-    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
+    "skipLibCheck": true /* Skip type checking all .d.ts files. */
   }
 }
diff --git a/turbo.json b/turbo.json
index 4c346b9..bc7d6c5 100644
--- a/turbo.json
+++ b/turbo.json
@@ -1,12 +1,70 @@
 {
   "$schema": "https://turbo.build/schema.json",
-  "globalDependencies": ["**/.env.*"],
+  "globalDependencies": [
+    "**/.env.*"
+  ],
   "tasks": {
     "build": {
       "dependsOn": ["^build"],
-      "outputs": ["dist/**", "*.js", "*.d.ts"]
+      "inputs": [
+        "src/**",
+        "public/**",
+        "index.html",
+        "package.json",
+        "tsconfig*.json",
+        "vite.config.*",
+        "components.json"
+      ],
+      "outputs": ["dist/**"]
+    },
+    "lint": {
+      "dependsOn": ["^build"],
+      "inputs": [
+        "src/**",
+        "package.json",
+        "eslint.config.*",
+        "tsconfig*.json"
+      ],
+      "outputs": [".eslintcache"]
+    },
+    "lint:check": {
+      "dependsOn": ["^build"],
+      "inputs": [
+        "src/**",
+        "package.json",
+        "eslint.config.*",
+        "tsconfig*.json"
+      ],
+      "outputs": [".eslintcache"]
+    },
+    "format": {
+      "inputs": [
+        "src/**",
+        "**/*.{json,css,md}",
+        ".prettierrc",
+        "package.json"
+      ]
+    },
+    "format:check": {
+      "inputs": [
+        "src/**",
+        "**/*.{json,css,md}",
+        ".prettierrc",
+        "package.json"
+      ]
+    },
+    "test": {
+      "dependsOn": ["^build"],
+      "inputs": [
+        "src/**",
+        "tests/**",
+        "package.json",
+        "tsconfig*.json",
+        "vite.config.*",
+        "vitest.config.*"
+      ],
+      "outputs": ["coverage/**"]
     },
-    "lint": {},
     "dev": {
       "cache": false,
       "persistent": true
