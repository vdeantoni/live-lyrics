# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# Live Lyrics

This project is a web-based application that displays the lyrics of the song currently playing on the user's Apple Music application. It features a client-server architecture, where the server retrieves the song information and the client presents it in a visually appealing way.

## Commands

This is a [Turborepo](https://turbo.build/) monorepo project. Use these commands:

- `pnpm dev`: Starts the development server for both the client and the server
- `pnpm build`: Builds the client and the server
- `pnpm lint`: Lints the client and the server

### Individual workspace commands:
- Client: `cd client && pnpm dev` (Vite dev server on port 5173)
- Server: `cd server && pnpm dev` (Node.js server on port 4000)

### Testing commands:
- `cd client && pnpm test:visual`: Run Playwright visual regression tests
- `cd client && pnpm test:visual:update`: Update Playwright visual test snapshots

## Architecture

### Monorepo Structure
- **Root**: Turborepo configuration with shared scripts
- **client/**: React + Vite frontend application
- **server/**: Node.js + Hono backend server

### Server (server/)
- **Framework**: Hono (lightweight web framework)
- **Runtime**: Node.js with TypeScript
- **Apple Music Integration**: Uses AppleScript via `osascript` to query macOS Music app
- **API Endpoints**:
  - `GET /music`: Returns current song info (name, artist, album, currentTime, duration, playerState)
  - `POST /music`: Controls playback (play/pause, seek)
- **Build**: Uses `tsc` for TypeScript compilation
- **Dev**: Uses `ts-node-dev` for hot reloading

### Client (client/)
- **Framework**: React 19 with TypeScript
- **Build Tool**: Vite
- **Styling**: Tailwind CSS v4 with custom CSS animations
- **Animations**: Framer Motion for complex animations (song name scrolling)
- **State Management**: @tanstack/react-query with persistent localStorage cache
- **Icons**: Lucide React for consistent iconography
- **UI Components**: Radix UI primitives (slider, aspect-ratio, button)
- **Key Features**:
  - Real-time music data fetching (300ms intervals)
  - Lyrics integration with external APIs (iTunes artwork, Lrclib lyrics)
  - Visual lyrics display with synchronized highlighting
  - Responsive design with landscape mode optimizations
  - Animated song name scrolling with hover pause/resume

### Component Architecture
- **LyricsVisualizer/**: Main lyrics display component hierarchy
  - `LyricsVisualizer.tsx`: Root container with layout orchestration
  - `LyricsProvider.tsx`: Data fetching, state management, and lyrics processing
  - `LyricsDisplay.tsx`: Visual effects wrapper and background rendering
  - `LyricsContent.tsx`: Actual lyrics rendering with synchronization
  - `Player.tsx`: Music playback controls with animated song name
  - `AnimatedSongName.tsx`: Framer Motion component for scrolling song titles
- **ui/**: Reusable UI components (buttons, sliders, skeletons)

### Data Flow
1. Server polls macOS Music app via AppleScript every request
2. Client queries server every 300ms using React Query
3. Client fetches additional data (artwork, lyrics) from external APIs
4. React Query provides caching and persistence across sessions
5. Components render synchronized lyrics with current playback position

## Development Notes

- **macOS Only**: Server requires macOS and the Music app for AppleScript integration
- **TypeScript**: Both client and server use TypeScript
- **Linting**: ESLint configured for both workspaces
- **Formatting**: Prettier for code formatting
- **Hot Reloading**: Available in both client (Vite) and server (ts-node-dev)
- **Testing**: Playwright for visual regression testing on the client
- **State Management**: Uses Jotai atoms for local state management and React Query for server state

## Visual Regression Testing Workflow

This project uses Playwright for visual regression testing to prevent unintended UI changes. Because screenshots can differ slightly between operating systems (e.g., macOS vs. Linux), the CI environment (which runs on Linux) is the **single source of truth** for all baseline screenshots.

### Local Development

When you run tests locally (`pnpm test:visual`), they may fail if your changes affect the UI. This is expected. The purpose of running tests locally is to get quick feedback and review the generated `diff` images in the `playwright-report`.

**Do not commit screenshot files generated on your local machine.**

### Establishing the Initial Baseline

The very first set of baseline screenshots must be generated by the CI.

1.  **Merge the PR with the test setup.** This adds the testing infrastructure to the `main` branch.
2.  **The first CI run will fail.** The next PR that modifies the `client/` directory will trigger the workflow, which will fail because no baseline exists.
3.  **Download the report artifact** from the failed CI run.
4.  **Extract the new screenshots.** Inside the report, you will find the newly generated screenshots (e.g., `home-page-portrait.png`).
5.  **Create a new PR.** Add these screenshots to the `client/tests/visual.spec.ts-snapshots` directory and merge it. This establishes the official baseline.

### Updating Baselines for Intentional UI Changes

When you make an intentional UI change, follow this process:

1.  **Push your code changes.** The visual regression test in your PR will fail, as expected.
2.  **Download the `playwright-report` artifact** from the failed CI run.
3.  **Verify the changes.** Inspect the "actual" and "diff" images in the report. If the changes are correct and intended, proceed to the next step.
4.  **Commit the new baseline.**
    *   Replace the old baseline screenshot in the `client/tests/visual.spec.ts-snapshots` directory with the new "actual" screenshot you downloaded from the CI report.
    *   Commit this updated screenshot to your pull request.
5.  **The CI will pass.** With the updated baseline in your PR, the test will now succeed. You can now merge the PR.